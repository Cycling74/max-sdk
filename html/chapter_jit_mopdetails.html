<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Max API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('chapter_jit_mopdetails.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Matrix Operator Details </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this chapter is to fill in the details of what a Matrix Operator is and how it works.</p>
<p>Matrix data in Jitter is typically considered raw data without respect to what the data represents. This permits simple fundamental operations to be applied to different sorts of data without needing to know any special information. For this reason most MOPs are general purpose. The jit.scalebias example from the preceding chapter could be considered video specific in its terminology, and type and plane count restrictions, but fundamentally it is just calculating a product and sum on each plane of an incoming matrix. In this chapter, we'll cover the details of how to configure MOP inputs and outputs, any attribute restrictions or linking for those inputs and outputs, what you must do in your matrix_calc method and how you expose your MOP to the Max environment, overriding default behavior if necessary.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_classes"></a>
Defining the MOP Jitter Class</h1>
<p>As discussed in the Matrix Operator Quick Start, for MOPs you must create an instance of jit_mop with the jit_object_new() function and add it to your Jitter class as an adornment with the <a class="el" href="group__classmod.html#ga408738c800435bf50d092ce52b223327" title="Adds an adornment to a class. ">jit_class_addadornment()</a> function. The jit_mop object holds information such as how many inputs and outputs the object has, what types, plane count, and dimension counts are supported, and how inputs should respond to incoming matrices. This information is only relevant to wrappers of the Jitter object which actually maintain additional matrices for inputs and outputs, as is the case with the MOP Max wrapper class. When used from C, Java, or JavaScript, it is the the programmer's responsibility to pass in matrices that conform to any restrictions imposed by the MOP. An example of instantiating and adding the jit_mop object is below.</p>
<div class="fragment"><div class="line"><span class="comment">// create a new instance of jit_mop with 1 input, and 1 output</span></div>
<div class="line">mop = jit_object_new(<a class="code" href="group__jitter.html#gace980d3ad9ef9fe8599b0802a5bc94cc">_jit_sym_jit_mop</a>,1,1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// add jit_mop object as an adornment to the class</span></div>
<div class="line"><a class="code" href="group__classmod.html#ga408738c800435bf50d092ce52b223327">jit_class_addadornment</a>(_jit_your_class,mop);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_io"></a>
The jit_mop_io Object</h1>
<p>Each instance of jit_mop contains some number of inputs and outputs, specified by the input and output arguments to the constructor. For each of these inputs and outputs there is an instance of jit_mop_io which records information specific to that input or output, such as type, plane count, and dimension restrictions. You can access the input or output objects by calling the getinput or getoutput methods with an integer index argument as below:</p>
<div class="fragment"><div class="line">input = jit_object_method(mop,<a class="code" href="group__jitter.html#gabfccc33dda7605b634fc5a79762b0807">_jit_sym_getinput</a>,1);</div>
<div class="line">output = jit_object_method(mop,<a class="code" href="group__jitter.html#ga59e892af19b57426b6ec0fac413fc472">_jit_sym_getoutput</a>,1);</div>
</div><!-- fragment --><p>Once you have obtained references to these inputs or outputs, you may query or set the jit_mop_io attributes. The attributes typically configured are: types, which is a list of symbols of permitted types, the first of which being the default; mindim and maxdim, which are the minimum and maximum permitted sizes for each dimension; mindimcount and maxdimcount, which are the minimum and maximum permitted number of dimensions permitted; minplanecount and maxplanecount, which are the minimum and maximum number of planes permitted; typelink, which is the flag that determines if the I/O should change its type to whatever the leftmost incoming matrix is; dimlink, which is the flag that determines if the I/O should change its dimensions to whatever the leftmost incoming matrix is; and planelink, which is the flag that determines if the I/O should change its plane count to whatever the leftmost incoming matrix is.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_restrictingattrs"></a>
Restricting Input/Output Attributes</h1>
<p>By default, all types, dimensions and plane count are permitted, and all linking is enabled. If you wish your MOP to have some specific restrictions, or difference in linking behaviors for any input or output in particular, you can set the corresponding attributes. For example, to set the plane count to always be four planes, you would set both the minplanecount and maxplanecount attributes to 4, as below:</p>
<div class="fragment"><div class="line">output = jit_object_method(mop,<a class="code" href="group__jitter.html#ga59e892af19b57426b6ec0fac413fc472">_jit_sym_getoutput</a>,1);</div>
<div class="line"><a class="code" href="group__attrmod.html#gafe9a672c8c2eee7c62038dc223beff66">jit_attr_setlong</a>(output,<a class="code" href="group__jitter.html#gac66e8d2508fabff1cc476ce79263d77b">_jit_sym_minplanecount</a>,4);</div>
<div class="line"><a class="code" href="group__attrmod.html#gafe9a672c8c2eee7c62038dc223beff66">jit_attr_setlong</a>(output,<a class="code" href="group__jitter.html#gaead621a8c72889478f33f12fc9d6441f">_jit_sym_maxplanecount</a>,4);</div>
</div><!-- fragment --><p>The jit.scalebias example could have set the planecount using the minplanecount and maxplanecount attributes rather than calling the utility function <a class="el" href="group__mopmod.html#gada02eaa2a5dc001cdb120a83cb093e25" title="Utility function to set the planecount attribute for all MOP inputs and outputs. ">jit_mop_single_planecount()</a>, which internally sets these attributes. A similar thing could be done to restrict type and dimensions. As for linking, if you wish to develop an object where the right hand input does not adapt to the size of the leftmost input, as is the case with jit.convolve, you would turn off the dimlink attribute, as below:</p>
<div class="fragment"><div class="line">input2 = jit_object_method(mop,<a class="code" href="group__jitter.html#gabfccc33dda7605b634fc5a79762b0807">_jit_sym_getinput</a>,2);</div>
<div class="line"><a class="code" href="group__attrmod.html#gafe9a672c8c2eee7c62038dc223beff66">jit_attr_setlong</a>(input2,<a class="code" href="group__jitter.html#ga2ffa341809ea194555c83a950742ea00">_jit_sym_dimlink</a>,0);</div>
</div><!-- fragment --><p>Similar could be done to remove type and planecount linking, and the utility functions <a class="el" href="group__mopmod.html#ga3f223fa6414f856e2484dbab7508945f" title="Utility function to disable all linking attributes for a MOP input. ">jit_mop_input_nolink()</a> and <a class="el" href="group__mopmod.html#ga6878129233c6c88c43b8512db44a43ff" title="Utility function to disable all linking attributes for a MOP output. ">jit_mop_output_nolink()</a> set all of these link attributes to false (zero).</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_ioproc"></a>
The ioproc Function</h1>
<p>For right hand matrix inputs, incoming data is typically copied by the MOP Max wrapper class. When an incoming matrix is received by the MOP Max wrapper class, a function called the ioproc is called, and the default ioproc copies the data, using the current input attributes (which might be linked to the lefthand input). The default ioproc can be overridden by calling the ioproc method followed by a function with the signature as listed below in the <a class="el" href="group__mopmod.html#ga9d6c3b36f1e4a7ef30d674eda4196a5c" title="MOP I/O procedure to copy and adapt to input. ">jit_mop_ioproc_copy_adapt()</a> function. The <a class="el" href="group__mopmod.html#ga9d6c3b36f1e4a7ef30d674eda4196a5c" title="MOP I/O procedure to copy and adapt to input. ">jit_mop_ioproc_copy_adapt()</a> function will always adapt to that inlet's incoming matrix attributes, as long as they don't conflict with any restrictions. The SDK project for jit.concat demonstrates the use of the <a class="el" href="group__mopmod.html#ga9d6c3b36f1e4a7ef30d674eda4196a5c" title="MOP I/O procedure to copy and adapt to input. ">jit_mop_ioproc_copy_adapt()</a> function.</p>
<div class="fragment"><div class="line">t_jit_err <a class="code" href="group__mopmod.html#ga9d6c3b36f1e4a7ef30d674eda4196a5c">jit_mop_ioproc_copy_adapt</a>(<span class="keywordtype">void</span> *mop, <span class="keywordtype">void</span> *mop_io, <span class="keywordtype">void</span> *matrix)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">void</span> *m; <span class="comment">// destination matrix</span></div>
<div class="line">   <a class="code" href="structt__jit__matrix__info.html">t_jit_matrix_info</a> info;</div>
<div class="line"></div>
<div class="line">   <span class="comment">// look up destination matrix from mop_io</span></div>
<div class="line">   <span class="keywordflow">if</span> (matrix&amp;&amp;(m=jit_object_method(mop_io,<a class="code" href="group__jitter.html#gacd090b153cd9d784843b2079a86d042f">_jit_sym_getmatrix</a>)))</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// retrieve incoming matrix info</span></div>
<div class="line">      jit_object_method(matrix,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65">_jit_sym_getinfo</a>,&amp;info);</div>
<div class="line"></div>
<div class="line">      <span class="comment">//restrict matrix info based on mop_io attribtues</span></div>
<div class="line">      jit_object_method(mop_io,<a class="code" href="group__jitter.html#ga0f492ef1025ad51ef914e5e1fc7d4ef7">_jit_sym_restrict_type</a>,&amp;info);</div>
<div class="line">      jit_object_method(mop_io,<a class="code" href="group__jitter.html#gabe6c52197fc2400c33ecd11277ca524d">_jit_sym_restrict_dim</a>,&amp;info);</div>
<div class="line">      jit_object_method(mop_io,<a class="code" href="group__jitter.html#gae5df0e1def5b65a004a8a2ae0e49b585">_jit_sym_restrict_planecount</a>,&amp;info);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// set destination matrix info</span></div>
<div class="line">      jit_object_method(m,<a class="code" href="group__jitter.html#ga17010e37d1d3a0695ed7d8fa8460582a">_jit_sym_setinfo</a>,&amp;info);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// copy the data with the frommatrix method</span></div>
<div class="line">      jit_object_method(m,<a class="code" href="group__jitter.html#gace24349d19e5308aa44e8bbf92b19442">_jit_sym_frommatrix</a>,matrix,NULL);</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_NONE;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_vario"></a>
Variable Inputs/Outputs</h1>
<p>You can specify variable input/output MOPs with a negative argument for input and/or outputs when constructing your jit_mop object. When the using variable inputs and/or outputs, there is not a jit_mop_io for each input and/or output within your class definition, and therefore the template type, dim, planecount, and linking attributes are not settable. If anything but the default behavior is required, you must accomplished it in another way — for example, either by overriding the jit_matrix method of the MOP Max wrapper class, or defining an mproc method to be called from within the standard jit_matrix method of the MOP Max wrapper class. The jit.pack, jit.unpack, jit.scissors, and jit.glue objects are a few SDK examples of MOPs with variable inputs and outputs. More information on overriding the jit_matrix, mproc, and other default methods of the MOP Max wrapper class is covered later in this chapter.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_adorn"></a>
Adding jit_mop as a Class Adornment</h1>
<p>Once you have configured all of the inputs and outputs of your jit_mop object, you must add your jit_mop object to your Jitter class with the <a class="el" href="group__classmod.html#ga408738c800435bf50d092ce52b223327" title="Adds an adornment to a class. ">jit_class_addadornment()</a> function. Adorments can be queried from the Jitter class at any time by calling <a class="el" href="group__classmod.html#ga1b040b25876a0905f60683413ce34ae6" title="Retrieves an adornment from a class. ">jit_class_adornment_get()</a> with the Jitter class pointer and the class name of the adornment object, as demonstrated below.</p>
<div class="fragment"><div class="line"><span class="comment">// add jit_mop object as an adornment to the class</span></div>
<div class="line"><a class="code" href="group__classmod.html#ga408738c800435bf50d092ce52b223327">jit_class_addadornment</a>(_jit_your_class,mop);</div>
<div class="line"></div>
<div class="line"><span class="comment">// look up jit_mop adornment</span></div>
<div class="line">mop = <a class="code" href="group__classmod.html#ga1b040b25876a0905f60683413ce34ae6">jit_class_adornment_get</a>(_jit_your_class,<a class="code" href="group__jitter.html#gace980d3ad9ef9fe8599b0802a5bc94cc">_jit_sym_jit_mop</a>);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_calc"></a>
The Matrix Calculation Method</h1>
<p>The entry point of the MOP Jitter class is the matrix_calc method, which is passed a list of matrices for the input, and a list of matrices for the output. It is not the responsibility of the matrix_calc method to perform any copying and adaptation behavior, but rather simply ensure that the matrices are valid, compatible, and if so, process. Certain objects may modify the dim, type, or planecount of the output matrices — e.g. the SDK project, jit.thin. However, it is the calling party's responsibility to perform any copying and conformance to MOP I/O restrictions as defined by the jit_mop_io objects—i.e. either the Max wrapper class, or the C, Java, or Javascript code which calls the matrix_calc method.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_access"></a>
Accessing the Input and Output Lists</h1>
<p>The input and output lists passed as arguments to your matrix_calc method are Jitter objects, and pointers to the individual inputs and outputs are acquired by calling the getindex method with an integer argument specifying the zero based list index. The return values should be tested to make sure they are not null. For example:</p>
<div class="fragment"><div class="line"><span class="comment">// get the zeroth index input and output from</span></div>
<div class="line"><span class="comment">// the corresponding input and output lists</span></div>
<div class="line">in_matrix    = jit_object_method(inputs,<a class="code" href="group__jitter.html#ga8479bd2e249eeebe55b73d505ddb3c5f">_jit_sym_getindex</a>,0);</div>
<div class="line">out_matrix  = jit_object_method(outputs,<a class="code" href="group__jitter.html#ga8479bd2e249eeebe55b73d505ddb3c5f">_jit_sym_getindex</a>,0);</div>
<div class="line"></div>
<div class="line"><span class="comment">// if the object and both input and output matrices</span></div>
<div class="line"><span class="comment">// are valid, then process, else return an error</span></div>
<div class="line"><span class="keywordflow">if</span> (x&amp;&amp;in_matrix&amp;&amp;out_matrix)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// ... process data ...</span></div>
<div class="line"></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_INVALID_PTR;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Technically, you can also pass in an instance of jit_matrix in place of a list for the input or output arguments, since jit_matrix has a getindex method which returns the jit_matrix instance. This is an example of dynamic binding at work. Another example of dynamic binding inside the matrix_calc method is that the list elements might be instances of jit_mop_io, rather than instances of jit_matrix. However, since Jitter uses dynamic binding and the jit_mop_io object is a "decorator" class for jit_matrix, all corresponding methods are passed on to the jit_matrix referenced by the jit_mop_io. In fact, any Jitter objects which respond to the standard interface for jit_matrix could be passed as inputs or outputs. If this seems confusing, you need not think about the underlying implementation further, but instead can assume that what is being passed in is simply an instance of jit_matrix. After all it should behave like one, even if it is not.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_locking"></a>
Locking and Unlocking Matrices</h1>
<p>Prior to working with a matrix, it is necessary to "lock" it so that the data and attributes will not be changed across the duration of the operation. This is accomplished by calling the jit_matrix instance's lock method with an integer argument of 1 (true) to lock the matrix. You should store the current lock state to restore when you're done processing. The lock operation should be the first thing to do after ensuring that the matrix objects are not NULL. For example</p>
<div class="fragment"><div class="line">   <span class="comment">// lock input and output matrices</span></div>
<div class="line">   in_savelock = (long) jit_object_method(in_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2">_jit_sym_lock</a>,1);</div>
<div class="line">   out_savelock = (long) jit_object_method(out_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2">_jit_sym_lock</a>,1);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// ... process data ...</span></div>
<div class="line"></div>
<div class="line">out:</div>
<div class="line">   <span class="comment">// restore matrix lock state to previous value</span></div>
<div class="line">   jit_object_method(out_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2">_jit_sym_lock</a>,out_savelock);</div>
<div class="line">   jit_object_method(in_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2">_jit_sym_lock</a>,in_savelock);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_info"></a>
Retrieving Matrix Information</h1>
<p>Once you have locked the matrices, you are ready to find out some information about them. This is accomplished by calling the getinfo method with a pointer to an instance of the <a class="el" href="structt__jit__matrix__info.html" title="Matrix information struct. ">t_jit_matrix_info</a> struct. The <a class="el" href="structt__jit__matrix__info.html" title="Matrix information struct. ">t_jit_matrix_info</a> struct contains several common attributes of the matrix and data organization of the matrix data, and is a useful way to obtain this information in one call, rather than querying each attribute individually. This information is typically tested to verify compatibility with any assumptions the matrix_calc method needs to make (since this method might be called from C, Java, or Javascript, you cannot assume that the MOP Max wrapper will have enforced these assumptions). It is also used to perform the appropriate pointer arithmetic based on type, plane count, dimensions, and the byte stride of those dimensions, since higher dimensions may not be tightly packed. The <a class="el" href="structt__jit__matrix__info.html" title="Matrix information struct. ">t_jit_matrix_info</a> struct is listed below:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>_jit_matrix_info</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">long</span>      size;         <span class="comment">// in bytes (0xFFFFFFFF=UNKNOWN)</span></div>
<div class="line">   <a class="code" href="structt__symbol.html">t_symbol</a>   *type;         <span class="comment">// primitive type</span></div>
<div class="line">   <span class="keywordtype">long</span>      flags;         <span class="comment">// matrix flags: my data?, handle?</span></div>
<div class="line">   <span class="keywordtype">long</span>      dimcount;      <span class="comment">// # of dimensions</span></div>
<div class="line">   <span class="keywordtype">long</span>      dim[<a class="code" href="group__jitter.html#ga3a74bc72df454ac5618a865fd3c56870">JIT_MATRIX_MAX_DIMCOUNT</a>]; <span class="comment">// dimension sizes</span></div>
<div class="line">   <span class="keywordtype">long</span>      dimstride[<a class="code" href="group__jitter.html#ga3a74bc72df454ac5618a865fd3c56870">JIT_MATRIX_MAX_DIMCOUNT</a>]; <span class="comment">// in bytes</span></div>
<div class="line">   <span class="keywordtype">long</span>      planecount;      <span class="comment">// # of planes</span></div>
<div class="line">} <a class="code" href="structt__jit__matrix__info.html">t_jit_matrix_info</a>;</div>
</div><!-- fragment --><p>And here is an example of calling the getinfo method to fill out the <a class="el" href="structt__jit__matrix__info.html" title="Matrix information struct. ">t_jit_matrix_info</a> struct: </p><div class="fragment"><div class="line"><span class="comment">// fill out matrix info structs for input and output</span></div>
<div class="line">jit_object_method(in_matrix,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65">_jit_sym_getinfo</a>,&amp;in_minfo);</div>
<div class="line">jit_object_method(out_matrix,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65">_jit_sym_getinfo</a>,&amp;out_minfo);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_data"></a>
Retrieving the Data Pointer</h1>
<p>The <a class="el" href="structt__jit__matrix__info.html" title="Matrix information struct. ">t_jit_matrix_info</a> struct is the meta data, but the actual matrix data can be accessed by acquiring the data pointer. You accomplish this by calling the matrix's getdata method, passing in a pointer to a pointer. This pointer can be any type, but it is typically a char (or byte) pointer since you may need to perform bytewise pointer arithmetic depending on the type and dimstride of your matrix. It is essential to verify that this pointer is valid before attempting to operate on the data, as demonstrated below.</p>
<div class="fragment"><div class="line"><span class="comment">// get matrix data pointers</span></div>
<div class="line">jit_object_method(in_matrix,<a class="code" href="group__jitter.html#ga3783fcca6255fb75cd048647ddebda3d">_jit_sym_getdata</a>,&amp;in_bp);</div>
<div class="line">jit_object_method(out_matrix,<a class="code" href="group__jitter.html#ga3783fcca6255fb75cd048647ddebda3d">_jit_sym_getdata</a>,&amp;out_bp);</div>
<div class="line"></div>
<div class="line"><span class="comment">// if data pointers are invalid, set error, and cleanup</span></div>
<div class="line"><span class="keywordflow">if</span> (!in_bp) { err=JIT_ERR_INVALID_INPUT; <span class="keywordflow">goto</span> out;}</div>
<div class="line"><span class="keywordflow">if</span> (!out_bp) { err=JIT_ERR_INVALID_OUTPUT; <span class="keywordflow">goto</span> out;}</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_dataproc"></a>
Processing the Data</h1>
<p>While it is possible to incorporate the data processing code inside the matrix_calc method, it is typical to rely on other routines to accomplish the N dimensional processing through recursion, potentially dispatching to multiple processors. The N-dimensional recursive processing function (typically named myobject_calculate_ndim) is discussed in the next section. You should pass in to the calculate_ndim function your object pointer, the overall dimension count, dimension sizes, planecount to consider in your calculation, together with the necessary matrix info structs and data pointers for each input and output. You can call this method directly as is the case in the following code:</p>
<div class="fragment"><div class="line"><span class="comment">// call calculate_ndim function directly in current thread</span></div>
<div class="line">jit_scalebias_calculate_ndim(x, dimcount, dim, planecount,</div>
<div class="line">   &amp;in_minfo, in_bp, &amp;out_minfo, out_bp);</div>
</div><!-- fragment --><p>Or you can call this method with the parallel processing utility functions provided with Jitter 1.5 to automatically dispatch the processing of large matrices across multiple processors when available. This figure illustrates the dispatching and calculating of the parallel processing utility:</p>
<div class="image">
<img src="figures/parallel-processing.jpg" />
</div>
<p>The parallel processing is accomplished by breaking up the matrix into smaller matrices that each reference subregions of the original inputs and outputs. No new objects are created, but rather just additional <a class="el" href="structt__jit__matrix__info.html" title="Matrix information struct. ">t_jit_matrix_info</a> structs and offset data pointers. Jitter 1.5 maintains a pool of worker threads for this purpose, so there is no thread creation overhead, but rather only some small thread synchronization overhead. Jitter 1.5 only dispatches across multiple threads when the data count is large enough to justify this thread synchronization overhead.</p>
<p>An important thing worth noting is that if your object performs some kind of spatial operation (e.g. convolution, rotation, scaling, etc.), you will either need to account for the matrix segmentation used by the parallel utilities or avoid using parallel processing and call directly in the current thread. Since the jit.scalebias example only processes one pixel at a time (i.e. a pointwise operation), it is inherently parallelizable, so it takes advantage of multiple processors as below:</p>
<div class="fragment"><div class="line"><span class="comment">// calculate, using the parallel utility function to</span></div>
<div class="line"><span class="comment">// call the calculate_ndim function in multiple</span></div>
<div class="line"><span class="comment">// threads if there are multiple processors available</span></div>
<div class="line"><a class="code" href="group__parallelutilmod.html#gaeb6c9b472d61bdda9fd33aa61a36df1f">jit_parallel_ndim_simplecalc2</a>(</div>
<div class="line">   (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)jit_scalebias_calculate_ndim,</div>
<div class="line">   x, dimcount, dim, planecount,</div>
<div class="line">   &amp;in_minfo, in_bp, &amp;out_minfo, out_bp,</div>
<div class="line">   0, 0 );</div>
</div><!-- fragment --><p>Important Note: If you aren't sure if your object is a pointwise operator, or don't fully understand how to make your algorithm parallelizable, you shouldn't use the parallel utility functions in your object. You should simply call the function directly.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_ndim"></a>
Processing N-Dimensional Matrices</h1>
<p>In the Matrix Operator Quick Start chapter, we discussed how to define a recursive function to process N-dimensional data in 2D slices, using the jit.scalebias object as an example. This example was restricted to processing four plane char data, but many Jitter objects work with any type of data and any plane count. In order to support all types and plane counts, there needs to be some case handling to know how to step through the data, and what type data to interpret as so that you can perform the appropriate operations. There are a number of ways to approach this logic, and decisions to make with respect to optimization. All this case handling can be a bit cumbersome, so when initially developing objects, it probably makes sense for you to focus on a single type and plane count, and only after you've adequately defined your operation, attempt to make your code robust to process any type of data and consider optimization of certain cases. The use of C macros, or C++ templates might be useful things to explore for better code re-use. As for code optimization, typically a decent atomic element to try and optimize is the "innermost" loop, avoiding branch conditions where possible.</p>
<p>This function is at the heart of the logic you will add in your own custom object. Since there is no "right way" to process this data, we won't cover any more code listings for the recursive N-dimensional processing function. However, the SDK projects that are good examples include: jit.clip, which performs a planar independent, pointwise operation (limiting numbers to some specified range); jit.rgb2luma, which performs a planar dependent, pointwise operation (converting RGB color to luminance); and jit.transpose, which performs a planar independent, spatial operation (rows become columns). For more ideas about N-dimensional matrix processing, we would recommend reading one of the several books available on 2D signal processing and/or image processing. Most of these concepts are easily generalized to higher dimensions.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_mopwrapdef"></a>
Defining the MOP Max Wrapper Class</h1>
<p>MOP Max wrapper classes typically have a large amount of default behavior, as setup through the max_jit_classex_mop_wrap function, based on the jit_mop Jitter class adornment, and user specified flags. You can either override all of the default behavior or just specific features. If you wish to override all of the default behavior, you can use the flag <a class="el" href="group__jitter.html#ga60cbfeaf26417a8d6561fb9acce523d5" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_ALL</a>, when calling the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class. ">max_jit_classex_mop_wrap()</a> function. If you need to make use of the jit_mop adornment(), the jit_mop can be looked up by calling the <a class="el" href="group__classmod.html#ga1b040b25876a0905f60683413ce34ae6" title="Retrieves an adornment from a class. ">jit_class_adornment_get()</a> method on the Jitter class. The jit_mop_io inputs and outputs can be queried and their attributes inspected, similar to how they were set in the MOP Jitter class definition, described earlier in this chapter. Here is an example of how to look up the jit_mop adornment of the jit.scalebias object:</p>
<div class="fragment"><div class="line"><span class="comment">// look up jitter class by name</span></div>
<div class="line">jclass = <a class="code" href="group__classmod.html#ga63eb9d25f881cd6fba11e24f9ac9b02f">jit_class_findbyname</a>(<a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;jit_scalebias&quot;</span>));</div>
<div class="line"><span class="comment">// look up jit_mop adornment</span></div>
<div class="line">mop = <a class="code" href="group__classmod.html#ga1b040b25876a0905f60683413ce34ae6">jit_class_adornment_get</a>(jclass,<a class="code" href="group__jitter.html#gace980d3ad9ef9fe8599b0802a5bc94cc">_jit_sym_jit_mop</a>);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_override"></a>
Overriding the jit_matrix Method</h1>
<p>By default, a jit_matrix method is added which automatically manages matrix copying and calculation based on the incoming data. Most typical MOPs simply use the default jit_matrix method. However there are instances where it is necessary to override the default MOP method to get special behavior, such as recording which matrix input data is being input to as is the case for the jit.op SDK example, or to do something other than standard copying and adaptation as is the case for the jit.pack or jit.str.op SDK examples, or to prevent any jit_matrix method at all, as is the case for the jit.noise SDK example. To prevent the default jit_matrix method from being defined, you can use the flag <a class="el" href="group__jitter.html#ga76b29cb7bf7f194cef194fb65df28ddd" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_JIT_MATRIX</a>, when calling the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class. ">max_jit_classex_mop_wrap()</a> function. To define your own jit_matrix method, you can add an <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6" title="request that args be passed as an array, the routine will check the types itself. ...">A_GIMME</a> method bound to the symbol jit_matrix, in your <a class="el" href="group__class.html#ga2fa22e46d14006d0de5cde70af1f6221" title="ext_main() is the entry point for an extern to be loaded, which all externs must implement this share...">ext_main()</a> function. Here's an example from jit.op:</p>
<div class="fragment"><div class="line"><span class="comment">// add custom jit_matrix method in ext_main()</span></div>
<div class="line"><a class="code" href="group__class__old.html#ga0d9bfa416fdd861d1b2fd2d17701cbb3">addmess</a>((<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)max_jit_op_jit_matrix, <span class="stringliteral">&quot;jit_matrix&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a81c1a8550f038db16a619167a70a79b6">A_GIMME</a>, 0);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> max_jit_op_jit_matrix(t_max_jit_op *x, <a class="code" href="structt__symbol.html">t_symbol</a> *s, <span class="keywordtype">short</span> argc,</div>
<div class="line">            <a class="code" href="structt__atom.html">t_atom</a> *argv)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span> (<a class="code" href="group__maxwrapmod.html#ga2c0d72889d3a89cbabe1001d55c86c3e">max_jit_obex_inletnumber_get</a>(x))</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// if matrix is received in right input,</span></div>
<div class="line">      <span class="comment">// record to override float or int input</span></div>
<div class="line">      x-&gt;last = OP_LAST_MATRIX;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="comment">// now pass on to the default jit_matrix method</span></div>
<div class="line">   <a class="code" href="group__maxmopmod.html#gaf2aa6f991436199827afe1f934ec9150">max_jit_mop_jit_matrix</a>(x,s,argc,argv);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The jit.pack and jit.str.op examples are a bit more involved and also better illustrate the kinds of tasks the default jit_matrix method performs.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_overridebang"></a>
Overriding the bang and outputmatrix Methods</h1>
<p>A MOP Max wrapper class typically has a bang and outputmatrix method. These two methods are typically equivalent, and by default, both send out the most recently calcuated matrix output. Certain objects that don't have a matrix output, like the jit.3m SDK example, typcially override these messages with their own bang and sometimes outputmatrix method. These methods can be overridden by using the <a class="el" href="group__jitter.html#gae93fd085f28675389848233a82521942" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_BANG</a> and <a class="el" href="group__jitter.html#ga7c51c91474bdbc40437dbd946df19cc5" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_OUTPUTMATRIX</a> flags when calling the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class. ">max_jit_classex_mop_wrap()</a> function. These flags are typically both passed in together.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_overridemore"></a>
Overriding the name, type, dim, and planecount Attributes</h1>
<p>For each input and output, other than the leftmost input, there is, by default, an attribute added to query and set that input or output's matrix attributes, including name, type, dim, and planecount. While overriding the default attribute behavior is conceivably necessary to perform very specialized behavior, it is not used by any of the SDK examples. To prevent the addition of the default attributes for name, type, dim, and planecount, you can use the <a class="el" href="group__jitter.html#ga2da79e2f2413304655b66637eeff0326" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_NAME</a>, <a class="el" href="group__jitter.html#gaf85d3bada9b15b7c5371e4cbeeffcaeb" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_TYPE</a>, <a class="el" href="group__jitter.html#gaf138ee8c3a7120b8914c2e815ed013bd" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_DIM</a>, and <a class="el" href="group__jitter.html#ga77553b6728bd9d5d6d18fe6e4d65a128" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_PLANECOUNT</a> flags when calling the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class. ">max_jit_classex_mop_wrap()</a> function. To define your own attributes, you would follow the same means of defining any attributes for a Max wrapper class with the appropriate attribute name you wish to override.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_overrideclear"></a>
Overriding the clear and notify Methods</h1>
<p>By default, a clear and a notify method are added. The default clear method clears each of the input and output matrices. The default notify method, <a class="el" href="group__maxmopmod.html#ga5032d682c77bcb7e2dcdf0e77d863d3c" title="Default notify method for a MOP Max wrapper object. ">max_jit_mop_notify()</a>, is called whenever any of the matrices maintained by the MOP are changed. If it is necessary to respond to additional notifications, it is important to call the max_jit_mop_notify function so that the MOP can perform any necessary maintenance with respect to input and output matrices, as demonstrated by the jit.notify SDK example. These methods can be overridden using the <a class="el" href="group__jitter.html#gaadd7ebf9b850b06496bdeb9414d181e4" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_CLEAR</a> and <a class="el" href="group__jitter.html#ga669c2f28bba1dfb4181ebae8f19488bc" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_NOTIFY</a> flags, respectively, when calling the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class. ">max_jit_classex_mop_wrap()</a> function. Object registration and notification is covered in detail in a future chapter, but the jit.notify notify method is provided as an example.</p>
<div class="fragment"><div class="line"><span class="comment">// s is the servername, msg is the message, ob is the server object pointer,</span></div>
<div class="line"><span class="comment">// and data is extra data the server might provide for a given message</span></div>
<div class="line"><span class="keywordtype">void</span> max_jit_notify_notify(</div>
<div class="line">   t_max_jit_notify *x, <a class="code" href="structt__symbol.html">t_symbol</a> *s, <a class="code" href="structt__symbol.html">t_symbol</a> *msg, <span class="keywordtype">void</span> *ob, <span class="keywordtype">void</span> *data)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">if</span> (msg==<a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;splat&quot;</span>)) {</div>
<div class="line">      <a class="code" href="group__console.html#ga8eebb1400d598f4423f925102d02970a">post</a>(<span class="stringliteral">&quot;notify: server=%s message=%s&quot;</span>,s-&gt;<a class="code" href="structt__symbol.html#ae2bf70cea045897c171f39116bf536c8">s_name</a>,msg-&gt;<a class="code" href="structt__symbol.html#ae2bf70cea045897c171f39116bf536c8">s_name</a>);</div>
<div class="line">      <span class="keywordflow">if</span> (!data) {</div>
<div class="line">         <a class="code" href="group__console.html#ga8a87d2e25431900a88722759ec115757">error</a>(<span class="stringliteral">&quot;splat message NULL pointer&quot;</span>);</div>
<div class="line">         <span class="keywordflow">return</span>;</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// here&#39;s where we output using the rightmost outlet</span></div>
<div class="line">      <span class="comment">// we just happen to know that &quot;data&quot; points to a t_atom[3]</span></div>
<div class="line">      <a class="code" href="group__maxwrapmod.html#ga161cd54f4612d26057e4140b56e14729">max_jit_obex_dumpout</a>(x,msg,3,(<a class="code" href="structt__atom.html">t_atom</a> *)data);</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// pass on to the default Max MOP notification method</span></div>
<div class="line">      <a class="code" href="group__maxmopmod.html#ga5032d682c77bcb7e2dcdf0e77d863d3c">max_jit_mop_notify</a>(x,s,msg);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_overrideadapt"></a>
Overriding the adapt and outputmode Attributes</h1>
<p>By default, adapt and outputmode attributes are added to the MOP Max Wrapper. These attributes determine whether or not to adapt to incoming matrix attributes, and whether or not the output should calculate a new output matrix, output the last calculated matrix (freeze), pass on the input matrix (bypass). To prevent the addition of the default attributes for adapt and outputmode, you can use the <a class="el" href="group__jitter.html#ga1c01c9fbad6e41293920117964654f61" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_ADAPT</a>, and <a class="el" href="group__jitter.html#gadad1691bc68342a60441cb884a89129d" title="mop flag ">MAX_JIT_MOP_FLAGS_OWN_OUTPUTMODE</a> flags when calling the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class. ">max_jit_classex_mop_wrap()</a> function. To define your own attributes, you would follow the same means of defining any attributes for a Max wrapper class with the appropriate attribute name you wish to override.</p>
<h1><a class="anchor" id="chapter_jit_mopdetails_mproc"></a>
Defining an mproc Method</h1>
<p>For many types of operations, it's not required to fully override the default jit_matrix method and any adaptation. If your object simply needs to override the way in which the Jitter class' matrix_calc method and outlet functions are called, you can do so by defining an mproc method, which will be called instead of the default behavior. The jit.3m SDK project is an example where after it calls the Jitter class' matrix_calc method, it queries the Jitter class' attributes and outputs max messages rather than the default jit_matrix message output.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> max_jit_3m_mproc(t_max_jit_3m *x, <span class="keywordtype">void</span> *mop)</div>
<div class="line">{</div>
<div class="line">   t_jit_err err;</div>
<div class="line"></div>
<div class="line">   <span class="comment">// call internal Jitter object&#39;s matrix_calc method</span></div>
<div class="line">   <span class="keywordflow">if</span> (err=(t_jit_err) jit_object_method(</div>
<div class="line">      <a class="code" href="group__maxwrapmod.html#ga063ab88bfc92c1a666f3ad6251834e20">max_jit_obex_jitob_get</a>(x),</div>
<div class="line">      <a class="code" href="group__jitter.html#ga3dde1a04b3c379fdebae36d532924b13">_jit_sym_matrix_calc</a>,</div>
<div class="line">      jit_object_method(mop,<a class="code" href="group__jitter.html#gad11662e6d22b8e40ce26c26c96ce666d">_jit_sym_getinputlist</a>),</div>
<div class="line">      jit_object_method(mop,<a class="code" href="group__jitter.html#gae1e7ca0918bca35d45bd8b26dc73733a">_jit_sym_getoutputlist</a>)))</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// report error if present</span></div>
<div class="line">      <a class="code" href="group__utilitymod.html#ga65b95cf6d8f87c67d0333a6baf17aa63">jit_error_code</a>(x,err);</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// query Jitter class and makes outlet calls</span></div>
<div class="line">      max_jit_3m_bang(x);</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopdetails_maxclassctor"></a>
The Max Class Constructor/Destructor</h1>
<p>As we discussed in the Matrix Operator Quick Start, inside your Max class' constructor you need to allocate the matrices necessary for the MOP inputs and outputs, the corresponding matrix inlets and outlets, process matrix arguments and other MOP setup. And in your destructor, you need to free oup MOP resources. Typically you would accomplish this all with the standard <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class. ">max_jit_mop_setup_simple()</a> and <a class="el" href="group__maxmopmod.html#ga441ff70d705e1eccff8297437c85e46c" title="Frees additional resources used by a MOP Max wrapper object. ">max_jit_mop_free()</a> functions, however there are some instances where you may need to introduce custom behavior.</p>
<h2><a class="anchor" id="chapter_jit_mopdetails_maxclassctor_vario"></a>
Variable Inputs/Outputs</h2>
<p>The <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class. ">max_jit_mop_setup_simple()</a> function calls <a class="el" href="group__maxmopmod.html#gaec99be7b60c1cec6a8391097d5008bc6" title="Creates input resources for a MOP Max wrapper object. ">max_jit_mop_inputs()</a> and <a class="el" href="group__maxmopmod.html#ga07f044bc4c7fe4380f31e150844948df" title="Creates output resources for a MOP Max wrapper object. ">max_jit_mop_outputs()</a> to define any necessary proxy inlets, outlets, and internal matrices. The listing for these functions are provided below to illustrate the default behavior, and a few SDK projects we recommend investigating further are jit.scissors, jit.glue, jit.pack, and jit.unpack.</p>
<div class="fragment"><div class="line">t_jit_err <a class="code" href="group__maxmopmod.html#gaec99be7b60c1cec6a8391097d5008bc6">max_jit_mop_inputs</a>(<span class="keywordtype">void</span> *x)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">void</span> *mop,*p,*m;</div>
<div class="line">   <span class="keywordtype">long</span> i,incount;</div>
<div class="line">   <a class="code" href="structt__jit__matrix__info.html">t_jit_matrix_info</a> info;</div>
<div class="line">   <a class="code" href="structt__symbol.html">t_symbol</a> *name;</div>
<div class="line"></div>
<div class="line">   <span class="comment">// look up object&#39;s MOP adornment</span></div>
<div class="line">   <span class="keywordflow">if</span> (x&amp;&amp;(mop=<a class="code" href="group__maxwrapmod.html#gae32503dc254a4f5fc1fb73fa0d7e0144">max_jit_obex_adornment_get</a>(x,<a class="code" href="group__jitter.html#gace980d3ad9ef9fe8599b0802a5bc94cc">_jit_sym_jit_mop</a>)))</div>
<div class="line">   {</div>
<div class="line">      incount  = <a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(mop,<a class="code" href="group__jitter.html#gaa0e855a6f84280795836b64e66f62866">_jit_sym_inputcount</a>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// add proxy inlet and internal matrix for</span></div>
<div class="line">      <span class="comment">// all inputs except leftmost inlet</span></div>
<div class="line">      <span class="keywordflow">for</span> (i=2;i&lt;=incount;i++) {</div>
<div class="line">         <a class="code" href="group__maxwrapmod.html#ga010c3e4a11d73d6553b7513719a19b7f">max_jit_obex_proxy_new</a>(x,(incount+1)-i); <span class="comment">// right to left</span></div>
<div class="line">         <span class="keywordflow">if</span> (p=jit_object_method(mop,<a class="code" href="group__jitter.html#gabfccc33dda7605b634fc5a79762b0807">_jit_sym_getinput</a>,i)) {</div>
<div class="line">            <a class="code" href="group__matrixmod.html#ga9c068d7781425345e99576a1955366af">jit_matrix_info_default</a>(&amp;info);</div>
<div class="line">            max_jit_mop_restrict_info(x,p,&amp;info);</div>
<div class="line">            name = jit_symbol_unique();</div>
<div class="line">            m = jit_object_new(<a class="code" href="group__jitter.html#ga8f405e5881e1e61c374ee50a0b65316e">_jit_sym_jit_matrix</a>,&amp;info);</div>
<div class="line">            m = <a class="code" href="group__objectmod.html#gabcf088a00f36b6af8ce5896b81e4d0ef">jit_object_register</a>(m,name);</div>
<div class="line">            <a class="code" href="group__attrmod.html#ga94cb0362d0ea100cdda79dd04abea5b3">jit_attr_setsym</a>(p,<a class="code" href="group__jitter.html#gad08a2de732bd1f003839ecc345fbcc1c">_jit_sym_matrixname</a>,name);</div>
<div class="line">            jit_object_method(p,<a class="code" href="group__jitter.html#ga78ceafb466150f724dbedf13834300c5">_jit_sym_matrix</a>,m);</div>
<div class="line">            <a class="code" href="group__objectmod.html#ga213166e8beeb29aca36c57cd07c722f1">jit_object_attach</a>(name, x);</div>
<div class="line">         }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> JIT_ERR_NONE;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_INVALID_PTR;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">t_jit_err <a class="code" href="group__maxmopmod.html#ga07f044bc4c7fe4380f31e150844948df">max_jit_mop_outputs</a>(<span class="keywordtype">void</span> *x)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">void</span> *mop,*p,*m;</div>
<div class="line">   <span class="keywordtype">long</span> i,outcount;</div>
<div class="line">   <a class="code" href="structt__jit__matrix__info.html">t_jit_matrix_info</a> info;</div>
<div class="line">   <a class="code" href="structt__symbol.html">t_symbol</a> *name;</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (x&amp;&amp;(mop=<a class="code" href="group__maxwrapmod.html#gae32503dc254a4f5fc1fb73fa0d7e0144">max_jit_obex_adornment_get</a>(x,<a class="code" href="group__jitter.html#gace980d3ad9ef9fe8599b0802a5bc94cc">_jit_sym_jit_mop</a>)))</div>
<div class="line">   {</div>
<div class="line">      outcount = <a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(mop,<a class="code" href="group__jitter.html#gad60b55c31584d561ebf94703f30db0c9">_jit_sym_outputcount</a>);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// add outlet and internal matrix for all outputs</span></div>
<div class="line">      <span class="keywordflow">for</span> (i=1;i&lt;=outcount;i++) {</div>
<div class="line">         <a class="code" href="group__maxmopmod.html#gade858d795f0afefa64a28acbb110f0a6">max_jit_mop_matrixout_new</a>(x,(outcount)-i);<span class="comment">// right to left</span></div>
<div class="line">         <span class="keywordflow">if</span> (p=jit_object_method(mop,<a class="code" href="group__jitter.html#ga59e892af19b57426b6ec0fac413fc472">_jit_sym_getoutput</a>,i)) {</div>
<div class="line">            <a class="code" href="group__matrixmod.html#ga9c068d7781425345e99576a1955366af">jit_matrix_info_default</a>(&amp;info);</div>
<div class="line">            max_jit_mop_restrict_info(x,p,&amp;info);</div>
<div class="line">            name = jit_symbol_unique();</div>
<div class="line">            m = jit_object_new(<a class="code" href="group__jitter.html#ga8f405e5881e1e61c374ee50a0b65316e">_jit_sym_jit_matrix</a>,&amp;info);</div>
<div class="line">            m = <a class="code" href="group__objectmod.html#gabcf088a00f36b6af8ce5896b81e4d0ef">jit_object_register</a>(m,name);</div>
<div class="line">            <a class="code" href="group__attrmod.html#ga94cb0362d0ea100cdda79dd04abea5b3">jit_attr_setsym</a>(p,<a class="code" href="group__jitter.html#gad08a2de732bd1f003839ecc345fbcc1c">_jit_sym_matrixname</a>,name);</div>
<div class="line">            jit_object_method(p,<a class="code" href="group__jitter.html#ga78ceafb466150f724dbedf13834300c5">_jit_sym_matrix</a>,m);</div>
<div class="line">            <a class="code" href="group__objectmod.html#ga213166e8beeb29aca36c57cd07c722f1">jit_object_attach</a>(name, x);</div>
<div class="line">         }</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">return</span> JIT_ERR_NONE;</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_INVALID_PTR;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="chapter_jit_mopdetails_maxclassctor_matargs"></a>
Matrix Arguments</h2>
<p>The <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class. ">max_jit_mop_setup_simple()</a> function calls <a class="el" href="group__maxmopmod.html#ga75f7f306602775484eaa1b3f9d3998f3" title="Process matrix arguments for a MOP Max wrapper object. ">max_jit_mop_matrix_args()</a> to read any matrix arguments, and if present send them to any linked inputs/outputs and disable the adapt attribute. The listing is provided below to illustrate the default behavior.</p>
<div class="fragment"><div class="line">t_jit_err <a class="code" href="group__maxmopmod.html#ga75f7f306602775484eaa1b3f9d3998f3">max_jit_mop_matrix_args</a>(<span class="keywordtype">void</span> *x, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html">t_atom</a> *argv)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">void</span> *mop,*p,*m;</div>
<div class="line">   <span class="keywordtype">long</span> incount,outcount,attrstart,i,j;</div>
<div class="line">   <a class="code" href="structt__jit__matrix__info.html">t_jit_matrix_info</a> info,info2;</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (!(mop=<a class="code" href="group__maxwrapmod.html#gae32503dc254a4f5fc1fb73fa0d7e0144">max_jit_obex_adornment_get</a>(x,<a class="code" href="group__jitter.html#gace980d3ad9ef9fe8599b0802a5bc94cc">_jit_sym_jit_mop</a>)))</div>
<div class="line">      <span class="keywordflow">return</span> JIT_ERR_GENERIC;</div>
<div class="line"></div>
<div class="line">   incount  = <a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(mop,<a class="code" href="group__jitter.html#gaa0e855a6f84280795836b64e66f62866">_jit_sym_inputcount</a>);</div>
<div class="line">   outcount = <a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(mop,<a class="code" href="group__jitter.html#gad60b55c31584d561ebf94703f30db0c9">_jit_sym_outputcount</a>);</div>
<div class="line"></div>
<div class="line">   <a class="code" href="group__matrixmod.html#ga9c068d7781425345e99576a1955366af">jit_matrix_info_default</a>(&amp;info);</div>
<div class="line"></div>
<div class="line">   attrstart = <a class="code" href="group__maxwrapmod.html#ga1a28ddf72d9bdcb2096df36384b63de6">max_jit_attr_args_offset</a>(argc,argv);</div>
<div class="line">   <span class="keywordflow">if</span> (attrstart&amp;&amp;argv) {</div>
<div class="line">      <a class="code" href="group__atommod.html#gabec1d1f329e0de98c3f3b6ee3c6b28c7">jit_atom_arg_getlong</a>(&amp;info.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803">planecount</a>, 0, attrstart, argv);</div>
<div class="line">      <a class="code" href="group__atommod.html#ga6be2fbebadc03614cd5e621da17ff289">jit_atom_arg_getsym</a>(&amp;info.<a class="code" href="structt__jit__matrix__info.html#aabcce88ec5bd51aea1662efef2adaf9a">type</a>, 1, attrstart, argv);</div>
<div class="line">      i=2; j=0;</div>
<div class="line">      <span class="keywordflow">while</span> (i&lt;attrstart) { <span class="comment">//dimensions</span></div>
<div class="line">         <a class="code" href="group__atommod.html#gabec1d1f329e0de98c3f3b6ee3c6b28c7">jit_atom_arg_getlong</a>(&amp;(info.<a class="code" href="structt__jit__matrix__info.html#a1910d191539aa64e8a949c62629e17b0">dim</a>[j]), i, attrstart, argv);</div>
<div class="line">         i++; j++;</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span> (j) info.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c">dimcount</a>=j;</div>
<div class="line"></div>
<div class="line">      <a class="code" href="group__attrmod.html#gafe9a672c8c2eee7c62038dc223beff66">jit_attr_setlong</a>(mop,<a class="code" href="group__jitter.html#gafa7c11d3fbbc17c42c90c1b3babba40b">_jit_sym_adapt</a>,0); <span class="comment">//adapt off</span></div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <a class="code" href="group__attrmod.html#gafe9a672c8c2eee7c62038dc223beff66">jit_attr_setlong</a>(mop,<a class="code" href="group__jitter.html#ga1f50b09597355a6d13fd346db875114c">_jit_sym_outputmode</a>,1);</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">for</span> (i=2;i&lt;=incount;i++) {</div>
<div class="line">      <span class="keywordflow">if</span> ((p=jit_object_method(mop,<a class="code" href="group__jitter.html#gabfccc33dda7605b634fc5a79762b0807">_jit_sym_getinput</a>,i)) &amp;&amp;</div>
<div class="line">         (m=jit_object_method(p,<a class="code" href="group__jitter.html#gacd090b153cd9d784843b2079a86d042f">_jit_sym_getmatrix</a>)))</div>
<div class="line">      {</div>
<div class="line">         jit_object_method(m,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65">_jit_sym_getinfo</a>,&amp;info2);</div>
<div class="line">         <span class="keywordflow">if</span> (<a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(p,<a class="code" href="group__jitter.html#ga7fe23ff07ff7cf4169d8eb881bf962b5">_jit_sym_typelink</a>)) {</div>
<div class="line">            info2.<a class="code" href="structt__jit__matrix__info.html#aabcce88ec5bd51aea1662efef2adaf9a">type</a> = info.<a class="code" href="structt__jit__matrix__info.html#aabcce88ec5bd51aea1662efef2adaf9a">type</a>;</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">if</span> (<a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(p,<a class="code" href="group__jitter.html#ga4fa8109186deaafd290961c3cb1c415f">_jit_sym_planelink</a>)) {</div>
<div class="line">            info2.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803">planecount</a> = info.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803">planecount</a>;</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">if</span> (<a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(p,<a class="code" href="group__jitter.html#ga2ffa341809ea194555c83a950742ea00">_jit_sym_dimlink</a>)) {</div>
<div class="line">            info2.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c">dimcount</a> = info.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c">dimcount</a>;</div>
<div class="line">            <span class="keywordflow">for</span> (j=0;j&lt;info2.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c">dimcount</a>;j++) {</div>
<div class="line">               info2.<a class="code" href="structt__jit__matrix__info.html#a1910d191539aa64e8a949c62629e17b0">dim</a>[j] = info.<a class="code" href="structt__jit__matrix__info.html#a1910d191539aa64e8a949c62629e17b0">dim</a>[j];</div>
<div class="line">            }</div>
<div class="line">         }</div>
<div class="line">         max_jit_mop_restrict_info(x,p,&amp;info2);</div>
<div class="line">         jit_object_method(m,<a class="code" href="group__jitter.html#ga17010e37d1d3a0695ed7d8fa8460582a">_jit_sym_setinfo</a>,&amp;info2);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">for</span> (i=1;i&lt;=outcount;i++) {</div>
<div class="line">      <span class="keywordflow">if</span> ((p=jit_object_method(mop,<a class="code" href="group__jitter.html#ga59e892af19b57426b6ec0fac413fc472">_jit_sym_getoutput</a>,i)) &amp;&amp;</div>
<div class="line">         (m=jit_object_method(p,<a class="code" href="group__jitter.html#gacd090b153cd9d784843b2079a86d042f">_jit_sym_getmatrix</a>)))</div>
<div class="line">      {</div>
<div class="line">         jit_object_method(m,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65">_jit_sym_getinfo</a>,&amp;info2);</div>
<div class="line">         <span class="keywordflow">if</span> (<a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(p,<a class="code" href="group__jitter.html#ga7fe23ff07ff7cf4169d8eb881bf962b5">_jit_sym_typelink</a>)) {</div>
<div class="line">            info2.<a class="code" href="structt__jit__matrix__info.html#aabcce88ec5bd51aea1662efef2adaf9a">type</a> = info.<a class="code" href="structt__jit__matrix__info.html#aabcce88ec5bd51aea1662efef2adaf9a">type</a>;</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">if</span> (<a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(p,<a class="code" href="group__jitter.html#ga4fa8109186deaafd290961c3cb1c415f">_jit_sym_planelink</a>)) {</div>
<div class="line">            info2.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803">planecount</a> = info.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803">planecount</a>;</div>
<div class="line">         }</div>
<div class="line">         <span class="keywordflow">if</span> (<a class="code" href="group__attrmod.html#ga6e2fcab8a3db5465853574fd51237d56">jit_attr_getlong</a>(p,<a class="code" href="group__jitter.html#ga2ffa341809ea194555c83a950742ea00">_jit_sym_dimlink</a>)) {</div>
<div class="line">            info2.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c">dimcount</a> = info.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c">dimcount</a>;</div>
<div class="line">            <span class="keywordflow">for</span> (j=0;j&lt;info2.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c">dimcount</a>;j++) {</div>
<div class="line">               info2.<a class="code" href="structt__jit__matrix__info.html#a1910d191539aa64e8a949c62629e17b0">dim</a>[j] = info.<a class="code" href="structt__jit__matrix__info.html#a1910d191539aa64e8a949c62629e17b0">dim</a>[j];</div>
<div class="line">            }</div>
<div class="line">         }</div>
<div class="line">         max_jit_mop_restrict_info(x,p,&amp;info2);</div>
<div class="line">         jit_object_method(m,<a class="code" href="group__jitter.html#ga17010e37d1d3a0695ed7d8fa8460582a">_jit_sym_setinfo</a>,&amp;info2);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_NONE;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2015, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
