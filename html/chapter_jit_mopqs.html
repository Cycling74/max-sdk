<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Max API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('chapter_jit_mopqs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Matrix Operator QuickStart </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The purpose of this chapter is to give a quick and high level overview of how to develop a simple Matrix Operator (MOP), which can process the matrix type most commonly used for video streamsâ€”i.e.</p>
<p>4 plane char data. For this task, we will use the jit.scalebias SDK example. More details such as how to make a Matrix Operator which deals with multiple types, plane count, dimensionality, inputs, outputs, etc. will appear in the following chapter. This chapter assumes familiarity with Jitter's multi-dimensional matrix representation and Matrix Operators used from the Max patcher, as discussed in the Jitter Tutorial, and as well as the preceding chapters on the Jitter object model and Max wrapper classes.</p>
<h1><a class="anchor" id="chapter_jit_mopqs_classes"></a>
Defining the MOP Jitter Class</h1>
<p>In the Jitter class definition, we introduce a few new concepts for Matrix Operators. In addition to the standard method and attribute definitions discussed in the Jitter object model chapter, you will want to define things like how many inputs and outputs the operator has, and what type, plane count, and dimension restrictions the operator has. These are accomplished by creating an instance of the jit_mop class, setting some state for the jit_mop object and adding this object as an adornment to your Jitter class. The following code segment references the jit.scalebias SDK example.</p>
<div class="fragment"><div class="line"><span class="comment">// create a new instance of jit_mop with 1 input, and 1 output</span></div>
<div class="line">mop = jit_object_new(<a class="code" href="group__jitter.html#gace980d3ad9ef9fe8599b0802a5bc94cc">_jit_sym_jit_mop</a>,1,1);</div>
<div class="line"></div>
<div class="line"><span class="comment">// enforce a single type for all inputs and outputs</span></div>
<div class="line"><a class="code" href="group__mopmod.html#ga8923e590eaf3cdb7d92c7f982ddc169f">jit_mop_single_type</a>(mop,<a class="code" href="group__jitter.html#ga3a06cf8d41c4f4c017c0bf825fec59f8">_jit_sym_char</a>);</div>
<div class="line"></div>
<div class="line"><span class="comment">// enforce a single plane count for all inputs and outputs</span></div>
<div class="line"><a class="code" href="group__mopmod.html#gada02eaa2a5dc001cdb120a83cb093e25">jit_mop_single_planecount</a>(mop,4);</div>
<div class="line"></div>
<div class="line"><span class="comment">// add the jit_mop object as an adornment to the class</span></div>
<div class="line"><a class="code" href="group__classmod.html#ga408738c800435bf50d092ce52b223327">jit_class_addadornment</a>(_jit_scalebias_class,mop);</div>
</div><!-- fragment --><p>You create your jit_mop instance in a similar fashion to creating your attribute instances, using jit_object_new(). The jit_mop constructor has two integer arguments for inputs and outputs, respectively. By default, each MOP input and output is unrestricted in plane count, type, and dimension, and also are linked to the plane count, type, and dimensions of the first (i.e. leftmost) input. This default behavior can be overridden, and this simple 4 plane, char type, jit.scalebias example enforces the corresponding type and plane count restrictions via the <a class="el" href="group__mopmod.html#ga8923e590eaf3cdb7d92c7f982ddc169f" title="Utility function to set the type attribute for all MOP inputs and outputs. ">jit_mop_single_type()</a> and <a class="el" href="group__mopmod.html#gada02eaa2a5dc001cdb120a83cb093e25" title="Utility function to set the planecount attribute for all MOP inputs and outputs. ">jit_mop_single_planecount()</a> utility functions. For more information on the jit_mop class, please see the following chapter on MOP details and the Jitter API reference.</p>
<p>Once you have created your jit_mop instance, and configured it according to the needs of your object, you add it as an adornment to your Jitter class with the jit_class_add_adornment() function. Adornments are one way for Jitter objects to have additional information, and in some instances behavior, tacked onto an existing class. Adornments will be discussed in detail in a later chapter.</p>
<p>You also want to define your matrix calculation method, where most of the work of a Matrix Operator occurs, with the <a class="el" href="group__classmod.html#ga3d3fb6b5f0696ac552b1b810a1656a73" title="Adds a named method to a class. ">jit_class_addmethod()</a> function as a private, untyped method bound to the symbol matrix_calc.</p>
<div class="fragment"><div class="line"><a class="code" href="group__classmod.html#ga3d3fb6b5f0696ac552b1b810a1656a73">jit_class_addmethod</a>(_jit_scalebias_class,</div>
<div class="line">   (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)jit_scalebias_matrix_calc,</div>
<div class="line">   <span class="stringliteral">&quot;matrix_calc&quot;</span>, <a class="code" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a">A_CANT</a>, 0L);</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopqs_ctordtor"></a>
The Jitter Class Constructor/Destructor</h1>
<p>You don't need to add anything special to your Matrix Operator's constructor or destructor, aside from the standard initialization and cleanup any Jitter object would need to do. Any internal matrices for input and outputs are maintained, and only required, by the Max wrapper's asynchronous interface. The Jitter MOP contains no matrices for inputs and outputs, but rather expects that the matrix calculation method is called with all inputs and outputs synchronously. When used from languages like C, Java, and JavaScript, it is up to the programmer to maintain and provide any matrices which are being passed into the matrix calculation method.</p>
<h1><a class="anchor" id="chapter_jit_mopqs_calc"></a>
The Matrix Calculation Method</h1>
<p>The most important method for Matrix Operators, and the one in which the most work typically occurs is in the matrix calculation, or "matrix_calc" method, which should be defined as a private, untyped method with the <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47af48193ec36e53b1507d81c49873c8d7a" title="cannot typecheck args ">A_CANT</a> type signature, and bound to the symbol "matrix_calc". In this method your object receives a list of input matrices and output matrices to use in its calculation. You need to lock access to these matrices, inquire about important attributes, and ensure that any requirements with respect to type, plane count, or dimensionality for the inputs are met before actually processing the data, unlocking access to the matrices and returning. It should be defined as in the following example.</p>
<div class="fragment"><div class="line">t_jit_err jit_scalebias_matrix_calc(t_jit_scalebias *x,</div>
<div class="line">   <span class="keywordtype">void</span> *inputs, <span class="keywordtype">void</span> *outputs)</div>
<div class="line">{</div>
<div class="line">   t_jit_err err=JIT_ERR_NONE;</div>
<div class="line">   <span class="keywordtype">long</span> in_savelock,out_savelock;</div>
<div class="line">   <a class="code" href="structt__jit__matrix__info.html">t_jit_matrix_info</a> in_minfo,out_minfo;</div>
<div class="line">   <span class="keywordtype">char</span> *in_bp,*out_bp;</div>
<div class="line">   <span class="keywordtype">long</span> i,dimcount,planecount,dim[<a class="code" href="group__jitter.html#ga3a74bc72df454ac5618a865fd3c56870">JIT_MATRIX_MAX_DIMCOUNT</a>];</div>
<div class="line">   <span class="keywordtype">void</span> *in_matrix,*out_matrix;</div>
<div class="line"></div>
<div class="line">   <span class="comment">// get the zeroth index input and output from</span></div>
<div class="line">   <span class="comment">// the corresponding input and output lists</span></div>
<div class="line">   in_matrix    = jit_object_method(inputs,<a class="code" href="group__jitter.html#ga8479bd2e249eeebe55b73d505ddb3c5f">_jit_sym_getindex</a>,0);</div>
<div class="line">   out_matrix    = jit_object_method(outputs,<a class="code" href="group__jitter.html#ga8479bd2e249eeebe55b73d505ddb3c5f">_jit_sym_getindex</a>,0);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// if the object and both input and output matrices</span></div>
<div class="line">   <span class="comment">// are valid, then process, else return an error</span></div>
<div class="line">   <span class="keywordflow">if</span> (x&amp;&amp;in_matrix&amp;&amp;out_matrix)</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// lock input and output matrices</span></div>
<div class="line">      in_savelock =</div>
<div class="line">         (long) jit_object_method(in_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2">_jit_sym_lock</a>,1);</div>
<div class="line">      out_savelock =</div>
<div class="line">         (long) jit_object_method(out_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2">_jit_sym_lock</a>,1);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// fill out matrix info structs for input and output</span></div>
<div class="line">      jit_object_method(in_matrix,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65">_jit_sym_getinfo</a>,&amp;in_minfo);</div>
<div class="line">      jit_object_method(out_matrix,<a class="code" href="group__jitter.html#gaa54d88c62f83bcde09d3e819f5cedf65">_jit_sym_getinfo</a>,&amp;out_minfo);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// get matrix data pointers</span></div>
<div class="line">      jit_object_method(in_matrix,<a class="code" href="group__jitter.html#ga3783fcca6255fb75cd048647ddebda3d">_jit_sym_getdata</a>,&amp;in_bp);</div>
<div class="line">      jit_object_method(out_matrix,<a class="code" href="group__jitter.html#ga3783fcca6255fb75cd048647ddebda3d">_jit_sym_getdata</a>,&amp;out_bp);</div>
<div class="line"></div>
<div class="line">      <span class="comment">// if data pointers are invalid, set error, and cleanup</span></div>
<div class="line">      <span class="keywordflow">if</span> (!in_bp) { err=JIT_ERR_INVALID_INPUT; <span class="keywordflow">goto</span> out;}</div>
<div class="line">      <span class="keywordflow">if</span> (!out_bp) { err=JIT_ERR_INVALID_OUTPUT; <span class="keywordflow">goto</span> out;}</div>
<div class="line"></div>
<div class="line">      <span class="comment">// enforce compatible types</span></div>
<div class="line">      <span class="keywordflow">if</span> ((in_minfo.<a class="code" href="structt__jit__matrix__info.html#aabcce88ec5bd51aea1662efef2adaf9a">type</a>!=<a class="code" href="group__jitter.html#ga3a06cf8d41c4f4c017c0bf825fec59f8">_jit_sym_char</a>) ||</div>
<div class="line">         (in_minfo.<a class="code" href="structt__jit__matrix__info.html#aabcce88ec5bd51aea1662efef2adaf9a">type</a>!=out_minfo.<a class="code" href="structt__jit__matrix__info.html#aabcce88ec5bd51aea1662efef2adaf9a">type</a>))</div>
<div class="line">      {</div>
<div class="line">         err=JIT_ERR_MISMATCH_TYPE;</div>
<div class="line">         <span class="keywordflow">goto</span> out;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// enforce compatible planecount</span></div>
<div class="line">      <span class="keywordflow">if</span> ((in_minfo.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803">planecount</a>!=4) ||</div>
<div class="line">         (out_minfo.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803">planecount</a>!=4))</div>
<div class="line">      {</div>
<div class="line">         err=JIT_ERR_MISMATCH_PLANE;</div>
<div class="line">         <span class="keywordflow">goto</span> out;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// get dimensions/planecount</span></div>
<div class="line">      dimcount   = out_minfo.<a class="code" href="structt__jit__matrix__info.html#a51f55844070b10955b23235f6ef68d1c">dimcount</a>;</div>
<div class="line">      planecount = out_minfo.<a class="code" href="structt__jit__matrix__info.html#a4f8e32123477684b18c83ca3d9079803">planecount</a>;</div>
<div class="line">      <span class="keywordflow">for</span> (i=0;i&lt;dimcount;i++)</div>
<div class="line">      {</div>
<div class="line">         <span class="comment">// if input and output are not matched in</span></div>
<div class="line">         <span class="comment">// size, use the intersection of the two</span></div>
<div class="line">         dim[i] = <a class="code" href="group__misc.html#ga3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(in_minfo.<a class="code" href="structt__jit__matrix__info.html#a1910d191539aa64e8a949c62629e17b0">dim</a>[i],out_minfo.<a class="code" href="structt__jit__matrix__info.html#a1910d191539aa64e8a949c62629e17b0">dim</a>[i]);</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// calculate, using the parallel utility function to</span></div>
<div class="line">      <span class="comment">// call the calculate_ndim function in multiple</span></div>
<div class="line">      <span class="comment">// threads if there are multiple processors available</span></div>
<div class="line">      <a class="code" href="group__parallelutilmod.html#gaeb6c9b472d61bdda9fd33aa61a36df1f">jit_parallel_ndim_simplecalc2</a>(</div>
<div class="line">         (<a class="code" href="group__datatypes.html#ga4b2c39d5bd0b08acd10bffed77f0e513">method</a>)jit_scalebias_calculate_ndim,</div>
<div class="line">         x, dimcount, dim, planecount,</div>
<div class="line">         &amp;in_minfo, in_bp, &amp;out_minfo, out_bp,</div>
<div class="line">         0, 0);</div>
<div class="line">   } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="keywordflow">return</span> JIT_ERR_INVALID_PTR;</div>
<div class="line">   }</div>
<div class="line"></div>
<div class="line">out:</div>
<div class="line">   <span class="comment">// restore matrix lock state to previous value</span></div>
<div class="line">   jit_object_method(out_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2">_jit_sym_lock</a>,out_savelock);</div>
<div class="line">   jit_object_method(in_matrix,<a class="code" href="group__jitter.html#ga27170862accb34a4a7d5940747ab93c2">_jit_sym_lock</a>,in_savelock);</div>
<div class="line">   <span class="keywordflow">return</span> err;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopqs_ndim"></a>
Processing N-Dimensional Matrices</h1>
<p>Since Jitter supports the processing of N-dimensional matrices where N can be any number from 1 to 32, most Matrix Operators are designed with a recursive function that will process the data in some lower dimensional slice, most often 2 dimensional. The recursive function that does this is typically named myobject_calculate_ndim(), and is called by your matrix_calc method either directly or via one of the parallel processing utility functions, which are discussed in a future chapter.</p>
<p>It is out of the scope of this documentation to provide a detailed tutorial on fixed point or pointer arithmetic, both of which are used in this example. The code increments a pointer through the matrix data, scaling each planar element of each matrix cell by some factor and adding some bias amount. This is done with fixed point arithmetic (assuming an 8bit fractional component), since a conversion from integer to floating point data and back is an expensive operation. The jit.scalebias object also has two modes, one which sums the planes together, and one which processes each plane independently. You can improve performance by case handling on a per row, rather than per cell basis, and reduce your code somewhat by case handling on a per row, rather than per matrix basis. While a slight performance increase could be made by handling on a per matrix basis, per row is usually a decent point at which to make such an optimization trade off.</p>
<div class="fragment"><div class="line"><span class="comment">// recursive function to handle higher dimension matrices,</span></div>
<div class="line"><span class="comment">// by processing 2D sections at a time</span></div>
<div class="line"><span class="keywordtype">void</span> jit_scalebias_calculate_ndim(t_jit_scalebias *x,</div>
<div class="line">   <span class="keywordtype">long</span> dimcount, <span class="keywordtype">long</span> *dim, <span class="keywordtype">long</span> planecount,</div>
<div class="line">   <a class="code" href="structt__jit__matrix__info.html">t_jit_matrix_info</a> *in_minfo, <span class="keywordtype">char</span> *bip,</div>
<div class="line">   <a class="code" href="structt__jit__matrix__info.html">t_jit_matrix_info</a> *out_minfo, <span class="keywordtype">char</span> *bop)</div>
<div class="line">{</div>
<div class="line">   <span class="keywordtype">long</span> i,j,width,height;</div>
<div class="line">   uchar *ip,*op;</div>
<div class="line">   <span class="keywordtype">long</span> ascale,rscale,gscale,bscale;</div>
<div class="line">   <span class="keywordtype">long</span> abias,rbias,gbias,bbias,sumbias;</div>
<div class="line">   <span class="keywordtype">long</span> tmp;</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (dimcount&lt;1) <span class="keywordflow">return</span>; <span class="comment">//safety</span></div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">switch</span>(dimcount)</div>
<div class="line">   {</div>
<div class="line">   <span class="keywordflow">case</span> 1:</div>
<div class="line">      <span class="comment">// if only 1D, interpret as 2D, falling through to 2D case</span></div>
<div class="line">      dim[1]=1;</div>
<div class="line">   <span class="keywordflow">case</span> 2:</div>
<div class="line">      <span class="comment">// convert floating point scale factors to a fixed point int</span></div>
<div class="line">      ascale = x-&gt;ascale*256.;</div>
<div class="line">      rscale = x-&gt;rscale*256.;</div>
<div class="line">      gscale = x-&gt;gscale*256.;</div>
<div class="line">      bscale = x-&gt;bscale*256.;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// convert floating point bias values to a fixed point int</span></div>
<div class="line">      abias  = x-&gt;abias*256.;</div>
<div class="line">      rbias  = x-&gt;rbias*256.;</div>
<div class="line">      gbias  = x-&gt;gbias*256.;</div>
<div class="line">      bbias  = x-&gt;bbias*256.;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// for efficiency in sum mode (1), make a single bias value</span></div>
<div class="line">      sumbias = (x-&gt;abias+x-&gt;rbias+x-&gt;gbias+x-&gt;bbias)*256.;</div>
<div class="line"></div>
<div class="line">      width  = dim[0];</div>
<div class="line">      height = dim[1];</div>
<div class="line"></div>
<div class="line">      <span class="comment">// for each row</span></div>
<div class="line">      <span class="keywordflow">for</span> (i=0;i&lt;height;i++)</div>
<div class="line">      {</div>
<div class="line">         <span class="comment">// increment data pointers according to byte stride</span></div>
<div class="line">         ip = bip + i*in_minfo-&gt;<a class="code" href="structt__jit__matrix__info.html#aa848a6bf50e6de47a8d72a28a11d56bc">dimstride</a>[1];</div>
<div class="line">         op = bop + i*out_minfo-&gt;<a class="code" href="structt__jit__matrix__info.html#aa848a6bf50e6de47a8d72a28a11d56bc">dimstride</a>[1];</div>
<div class="line"></div>
<div class="line">         <span class="keywordflow">switch</span> (x-&gt;mode) {</div>
<div class="line">         <span class="keywordflow">case</span> 1:</div>
<div class="line">            <span class="comment">// sum together, clamping to the range 0-255</span></div>
<div class="line">            <span class="comment">// and set all output planes</span></div>
<div class="line">            <span class="keywordflow">for</span> (j=0;j&lt;width;j++) {</div>
<div class="line">               tmp  = (long)(*ip++)*ascale;</div>
<div class="line">               tmp += (long)(*ip++)*rscale;</div>
<div class="line">               tmp += (long)(*ip++)*gscale;</div>
<div class="line">               tmp += (long)(*ip++)*bscale;</div>
<div class="line">               tmp  = (tmp&gt;&gt;8L) + sumbias;</div>
<div class="line">               tmp  = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);</div>
<div class="line">               *op++ = tmp;</div>
<div class="line">               *op++ = tmp;</div>
<div class="line">               *op++ = tmp;</div>
<div class="line">               *op++ = tmp;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">         <span class="keywordflow">default</span>:</div>
<div class="line">            <span class="comment">// apply to each plane individually</span></div>
<div class="line">            <span class="comment">// clamping to the range 0-255</span></div>
<div class="line">            <span class="keywordflow">for</span> (j=0;j&lt;width;j++) {</div>
<div class="line">               tmp = (((long)(*ip++)*ascale)&gt;&gt;8L)+abias;</div>
<div class="line">               *op++ = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);</div>
<div class="line">               tmp = (((long)(*ip++)*rscale)&gt;&gt;8L)+rbias;</div>
<div class="line">               *op++ = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);</div>
<div class="line">               tmp = (((long)(*ip++)*gscale)&gt;&gt;8L)+gbias;</div>
<div class="line">               *op++ = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);</div>
<div class="line">               tmp = (((long)(*ip++)*bscale)&gt;&gt;8L)+bbias;</div>
<div class="line">               *op++ = (tmp&gt;255)?255:((tmp&lt;0)?0:tmp);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">         }</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">break</span>;</div>
<div class="line">   <span class="keywordflow">default</span>:</div>
<div class="line">      <span class="comment">// if processing higher dimension than 2D,</span></div>
<div class="line">      <span class="comment">// for each lower dimensioned slice, set</span></div>
<div class="line">      <span class="comment">// base pointer and recursively call this function</span></div>
<div class="line">      <span class="comment">// with decremented dimcount and new base pointers</span></div>
<div class="line">      <span class="keywordflow">for</span>   (i=0;i&lt;dim[dimcount-1];i++)</div>
<div class="line">      {</div>
<div class="line">         ip = bip + i*in_minfo-&gt;<a class="code" href="structt__jit__matrix__info.html#aa848a6bf50e6de47a8d72a28a11d56bc">dimstride</a>[dimcount-1];</div>
<div class="line">         op = bop + i*out_minfo-&gt;<a class="code" href="structt__jit__matrix__info.html#aa848a6bf50e6de47a8d72a28a11d56bc">dimstride</a>[dimcount-1];</div>
<div class="line">         jit_scalebias_calculate_ndim(x,dimcount1,</div>
<div class="line">            dim,planecount,in_minfo,ip,out_minfo,op);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Rather than using multidimensional arrays, Jitter matrix data is packed in a single dimensional array, with defined byte strides for each dimension for greatest flexibility. This permits matrices to reference subregions of larger matrices, as well as support data that is not tightly packed. Therefore, rather than using multidimensional array syntax, this code uses pointer arithmetic to access each plane of each cell of the matrix, adding the corresponding byte strides to the base pointer for each dimension across which it is iterating. These byte strides are stored in the dimstride entry of the <a class="el" href="structt__jit__matrix__info.html" title="Matrix information struct. ">t_jit_matrix_info</a> struct. Note that Jitter requires that planes within a cell, and cells across the first dimension (dim[0]) are tightly packed. The above code assumes that this is the case, using a simple pointer increment for each plane and cell, rather than looking up byte strides for dim[0].</p>
<h1><a class="anchor" id="chapter_jit_mopqs_wrapperdef"></a>
Defining the MOP Max Wrapper Class</h1>
<p>In order to use the MOP class in a Max patcher you need to make a Max wrapper class. In addition to the standard methods used to wrap any Jitter class, MOPs need to add special methods and information to the Max class. One of the things that needs to happen is that the Max wrapper class needs to allocate and maintain instances of jit.matrix for each matrix input and output other than the leftmost input, to accommodate Max's asynchronous event model. In order to perform this maintenance, the Max wrapper class must have special methods and attributes for setting the type, plane count, dimensions, adaptability, and named references for the internal matrices. All of these messages are exclusive to the Max wrapper implementation, and are not used by the C, Java, or JavaScript usage of Matrix Operators. There are also common methods and attributes for the matrix output mode, and the jit_matrix and bang messages, all of which are specific to the MOP's Max wrapper. These special attributes and methods are added by the <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class. ">max_jit_classex_mop_wrap()</a> function, which should be called inside your Max external's <a class="el" href="group__class.html#ga2fa22e46d14006d0de5cde70af1f6221" title="ext_main() is the entry point for an extern to be loaded, which all externs must implement this share...">ext_main()</a> function, after calling <a class="el" href="group__maxwrapmod.html#ga773b6e6430d9de2e295419c7f038979e" title="Allocates and initializes special t_max_jit_classex data, used by the Max wrapper class...">max_jit_classex_setup()</a> and <a class="el" href="group__classmod.html#ga63eb9d25f881cd6fba11e24f9ac9b02f" title="Retrieves class pointer associated with name provided. ">jit_class_findbyname()</a>, and before calling <a class="el" href="group__maxwrapmod.html#ga9b8377bdccc2497e02582c72204b5250" title="Adds standard Jitter methods, as well as public methods and attributes of the specified Jitter class...">max_jit_classex_standard_wrap()</a>. Several default methods and attributes can be overridden using the various flags that can be combined for the flags argument to <a class="el" href="group__maxmopmod.html#ga7e08584771f58ce1fe0b190d27b5759b" title="Adds default methods and attributes to the MOP Max wrapper class. ">max_jit_classex_mop_wrap()</a>. These flags, which for most simple MOPs won't be necessary, are listed below.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_ALL           0xFFFFFFFF</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_JIT_MATRIX    0x00000001</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_BANG          0x00000002</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_OUTPUTMATRIX  0x00000004</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_NAME          0x00000008</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_TYPE          0x00000010</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_DIM           0x00000020</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_PLANECOUNT    0x00000040</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_CLEAR         0x00000080</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_NOTIFY        0x00000100</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_ADAPT         0x00000200</span></div>
<div class="line"><span class="preprocessor">#define MAX_JIT_MOP_FLAGS_OWN_OUTPUTMODE    0x00000400</span></div>
</div><!-- fragment --><h1><a class="anchor" id="chapter_jit_mopqs_maxctordtor"></a>
The Max Class Constructor/Destructor</h1>
<p>Inside your Max class' constructor you need to allocate the matrices necessary for the MOP inputs and outputs, the corresponding matrix inlets and outlets, process matrix arguments and other MOP setup. The <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class. ">max_jit_mop_setup_simple()</a> function takes care of these functions and some of the other necessary tasks of wrapping your Jitter instance. As such, the use of this function simplifies your Jitter class wrapping even further for the simple case where no special behavior, incompatible with <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class. ">max_jit_mop_setup_simple()</a> is required. Here is the constructor for the Max class of the jit.scalebias object.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> *max_jit_scalebias_new(<a class="code" href="structt__symbol.html">t_symbol</a> *s, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html">t_atom</a> *argv)</div>
<div class="line">{</div>
<div class="line">   t_max_jit_scalebias *x;</div>
<div class="line">   <span class="keywordtype">void</span> *o;</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">if</span> (x = (t_max_jit_scalebias *)</div>
<div class="line">      <a class="code" href="group__maxwrapmod.html#gacf7fc6f3f87db8515f61b12efbcc9073">max_jit_obex_new</a>(</div>
<div class="line">      max_jit_scalebias_class,</div>
<div class="line">      <a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;jit_scalebias&quot;</span>)))</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// instantiate Jitter object</span></div>
<div class="line">      <span class="keywordflow">if</span> (o=jit_object_new(<a class="code" href="group__symbol.html#ga5d8db08b384aeb76eaee85a15f46fbcb">gensym</a>(<span class="stringliteral">&quot;jit_scalebias&quot;</span>)))</div>
<div class="line">      {</div>
<div class="line">         <span class="comment">// handle standard MOP max wrapper setup tasks</span></div>
<div class="line">         <a class="code" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94">max_jit_mop_setup_simple</a>(x,o,argc,argv);</div>
<div class="line"></div>
<div class="line">         <span class="comment">// process attribute arguments</span></div>
<div class="line">         <a class="code" href="group__maxwrapmod.html#gac1ffd4864421154c8e6364b5df9a09ff">max_jit_attr_args</a>(x,argc,argv);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">      {</div>
<div class="line">         <a class="code" href="group__console.html#ga8a87d2e25431900a88722759ec115757">error</a>(<span class="stringliteral">&quot;jit.scalebias: could not allocate object&quot;</span>);</div>
<div class="line">         <a class="code" href="group__class__old.html#gadf30646e52376a37b93cc20efac65636">freeobject</a>(x);</div>
<div class="line">      }</div>
<div class="line">   }</div>
<div class="line">   <span class="keywordflow">return</span> (x);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Below is the listing of the <a class="el" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94" title="Initializes default state and resources for MOP Max wrapper class. ">max_jit_mop_setup_simple()</a> function, demonstrating the smaller pieces, it manages for you. If your object has special requirements, you can use whatever subset of the following function as necessary.</p>
<div class="fragment"><div class="line">t_jit_err <a class="code" href="group__maxmopmod.html#gac3eaca207281516b72e81f0dc5f4bf94">max_jit_mop_setup_simple</a>(<span class="keywordtype">void</span> *x, <span class="keywordtype">void</span> *o, <span class="keywordtype">long</span> argc, <a class="code" href="structt__atom.html">t_atom</a> *argv)</div>
<div class="line">{</div>
<div class="line">   <a class="code" href="group__maxwrapmod.html#gaa1b174cf92680ca46bfb189a812d2a65">max_jit_obex_jitob_set</a>(x,o);</div>
<div class="line">   <a class="code" href="group__maxwrapmod.html#ga8e63a402ecf8cef78a9093c774159a9e">max_jit_obex_dumpout_set</a>(x,<a class="code" href="group__inout.html#gac25db50a2a7eb76c5e057dd907c11d44">outlet_new</a>(x,NULL));</div>
<div class="line">   <a class="code" href="group__maxmopmod.html#ga21f81f6d30f54a671a78a6b44986392a">max_jit_mop_setup</a>(x);</div>
<div class="line">   <a class="code" href="group__maxmopmod.html#gaec99be7b60c1cec6a8391097d5008bc6">max_jit_mop_inputs</a>(x);</div>
<div class="line">   <a class="code" href="group__maxmopmod.html#ga07f044bc4c7fe4380f31e150844948df">max_jit_mop_outputs</a>(x);</div>
<div class="line">   <a class="code" href="group__maxmopmod.html#ga75f7f306602775484eaa1b3f9d3998f3">max_jit_mop_matrix_args</a>(x,argc,argv);</div>
<div class="line"></div>
<div class="line">   <span class="keywordflow">return</span> JIT_ERR_NONE;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In your Max class' destructor, you need to free the resources allocated for your MOP. This is accomplished with the <a class="el" href="group__maxmopmod.html#ga441ff70d705e1eccff8297437c85e46c" title="Frees additional resources used by a MOP Max wrapper object. ">max_jit_mop_free()</a> function, which should be called before you free your internal Jitter instance, and your Max class' obex data. As an example, the jit.scalebias destructor is listed below.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> max_jit_scalebias_free(t_max_jit_scalebias *x)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// free MOP max wrapper resources</span></div>
<div class="line">   <a class="code" href="group__maxmopmod.html#ga441ff70d705e1eccff8297437c85e46c">max_jit_mop_free</a>(x);</div>
<div class="line"></div>
<div class="line">   <span class="comment">// lookup internal Jitter object instance and free</span></div>
<div class="line">   <a class="code" href="group__objectmod.html#ga64970b62e5afe7a2cbd57efd6e9e9f74">jit_object_free</a>(<a class="code" href="group__maxwrapmod.html#ga063ab88bfc92c1a666f3ad6251834e20">max_jit_obex_jitob_get</a>(x));</div>
<div class="line"></div>
<div class="line"></div>
<div class="line">   <span class="comment">// free resources associated with obex entry</span></div>
<div class="line">   <a class="code" href="group__maxwrapmod.html#gabcf9c466a6baa22994a66e30b54e7dd6">max_jit_obex_free</a>(x);</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2015, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
