<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>Max API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
	<div id="c74header">
		<img src="header.png" height="100" />
	</div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__dictobj.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dictionary Passing API<div class="ingroups"><a class="el" href="group__datastore.html">Data Storage</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>The Dictionary Passing API defines a means by which <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> instances may be passed between Max objects in a way similar to the way Jitter Matrices are passed between objects.  
<a href="#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Dictionary Passing API:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<center><table><tr><td><img src="group__dictobj.png" border="0" alt="" usemap="#group____dictobj"/>
<map name="group____dictobj" id="group____dictobj">
<area shape="rect" id="node2" href="group__datastore.html" title="Max provides a number of ways of storing and manipulating data at a high level. " alt="" coords="5,5,105,31"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa969bb93c3259b7346ac4010becb22e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#ga06f35de4fc025809ab1cbb06f55b6495">BEGIN_USING_C_LINKAGE</a> <a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#gaa969bb93c3259b7346ac4010becb22e4">dictobj_register</a> (<a class="el" href="structt__dictionary.html">t_dictionary</a> *d, <a class="el" href="structt__symbol.html">t_symbol</a> **name)</td></tr>
<tr class="memdesc:gaa969bb93c3259b7346ac4010becb22e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> with the dictionary passing system and map it to a unique name.  <a href="#gaa969bb93c3259b7346ac4010becb22e4">More...</a><br /></td></tr>
<tr class="separator:gaa969bb93c3259b7346ac4010becb22e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00aafb1e4ce7b94bd7a73b3620342a8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#ga00aafb1e4ce7b94bd7a73b3620342a8c">dictobj_unregister</a> (<a class="el" href="structt__dictionary.html">t_dictionary</a> *d)</td></tr>
<tr class="memdesc:ga00aafb1e4ce7b94bd7a73b3620342a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> with the dictionary passing system.  <a href="#ga00aafb1e4ce7b94bd7a73b3620342a8c">More...</a><br /></td></tr>
<tr class="separator:ga00aafb1e4ce7b94bd7a73b3620342a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf490af832d2059b1ff1cc8a3c34f1e4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#gaf490af832d2059b1ff1cc8a3c34f1e4c">dictobj_findregistered_clone</a> (<a class="el" href="structt__symbol.html">t_symbol</a> *name)</td></tr>
<tr class="memdesc:gaf490af832d2059b1ff1cc8a3c34f1e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> for a given name, and return a <em>copy</em> of that dictionary When you are done, do <em>not</em> call <a class="el" href="group__dictobj.html#ga893bb067b41415d9a665f0d8087f7c76" title="For a t_dictionary/name that was previously retained with dictobj_findregistered_retain(), release it (decrement its reference count). ">dictobj_release()</a> on the dictionary, because you are working on a copy rather than on a retained pointer.  <a href="#gaf490af832d2059b1ff1cc8a3c34f1e4c">More...</a><br /></td></tr>
<tr class="separator:gaf490af832d2059b1ff1cc8a3c34f1e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa95f7a94044a2c1bea5f4b84fc2f5620"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#gaa95f7a94044a2c1bea5f4b84fc2f5620">dictobj_findregistered_retain</a> (<a class="el" href="structt__symbol.html">t_symbol</a> *name)</td></tr>
<tr class="memdesc:gaa95f7a94044a2c1bea5f4b84fc2f5620"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> for a given name, return a pointer to that <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a>, and increment its reference count.  <a href="#gaa95f7a94044a2c1bea5f4b84fc2f5620">More...</a><br /></td></tr>
<tr class="separator:gaa95f7a94044a2c1bea5f4b84fc2f5620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga893bb067b41415d9a665f0d8087f7c76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#ga893bb067b41415d9a665f0d8087f7c76">dictobj_release</a> (<a class="el" href="structt__dictionary.html">t_dictionary</a> *d)</td></tr>
<tr class="memdesc:ga893bb067b41415d9a665f0d8087f7c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a>/name that was previously retained with <a class="el" href="group__dictobj.html#gaa95f7a94044a2c1bea5f4b84fc2f5620" title="Find the t_dictionary for a given name, return a pointer to that t_dictionary, and increment its refe...">dictobj_findregistered_retain()</a>, release it (decrement its reference count).  <a href="#ga893bb067b41415d9a665f0d8087f7c76">More...</a><br /></td></tr>
<tr class="separator:ga893bb067b41415d9a665f0d8087f7c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82b86e621c2e9a280d0ed266710a1a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#ga82b86e621c2e9a280d0ed266710a1a76">dictobj_namefromptr</a> (<a class="el" href="structt__dictionary.html">t_dictionary</a> *d)</td></tr>
<tr class="memdesc:ga82b86e621c2e9a280d0ed266710a1a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the name associated with a given <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a>.  <a href="#ga82b86e621c2e9a280d0ed266710a1a76">More...</a><br /></td></tr>
<tr class="separator:ga82b86e621c2e9a280d0ed266710a1a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b50af649740589d8a86c114d8499621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#ga6b50af649740589d8a86c114d8499621">dictobj_outlet_atoms</a> (void *out, long argc, <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:ga6b50af649740589d8a86c114d8499621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send atoms to an outlet in your Max object, handling complex datatypes that may be present in those atoms.  <a href="#ga6b50af649740589d8a86c114d8499621">More...</a><br /></td></tr>
<tr class="separator:ga6b50af649740589d8a86c114d8499621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf42c50812bf8215eda9bcb0595ecf213"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#gaf42c50812bf8215eda9bcb0595ecf213">dictobj_atom_safety</a> (<a class="el" href="structt__atom.html">t_atom</a> *a)</td></tr>
<tr class="memdesc:gaf42c50812bf8215eda9bcb0595ecf213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that an atom is safe for passing.  <a href="#gaf42c50812bf8215eda9bcb0595ecf213">More...</a><br /></td></tr>
<tr class="separator:gaf42c50812bf8215eda9bcb0595ecf213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a857a7c9c5d852126c87e5a8968a1a7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#ga4a857a7c9c5d852126c87e5a8968a1a7">dictobj_atom_safety_flags</a> (<a class="el" href="structt__atom.html">t_atom</a> *a, long flags)</td></tr>
<tr class="memdesc:ga4a857a7c9c5d852126c87e5a8968a1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that an atom is safe for passing.  <a href="#ga4a857a7c9c5d852126c87e5a8968a1a7">More...</a><br /></td></tr>
<tr class="separator:ga4a857a7c9c5d852126c87e5a8968a1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16fa5b430f0116b582d0909604d34a67"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#ga16fa5b430f0116b582d0909604d34a67">dictobj_validate</a> (const <a class="el" href="structt__dictionary.html">t_dictionary</a> *schema, const <a class="el" href="structt__dictionary.html">t_dictionary</a> *candidate)</td></tr>
<tr class="memdesc:ga16fa5b430f0116b582d0909604d34a67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate the contents of a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> against a second <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> containing a schema.  <a href="#ga16fa5b430f0116b582d0909604d34a67">More...</a><br /></td></tr>
<tr class="separator:ga16fa5b430f0116b582d0909604d34a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a5d441174d5fa9fd90d40faf82363f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#gad9a5d441174d5fa9fd90d40faf82363f">dictobj_jsonfromstring</a> (long *jsonsize, char **json, const char *str)</td></tr>
<tr class="memdesc:gad9a5d441174d5fa9fd90d40faf82363f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a C-string of <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> into a C-string of JSON.  <a href="#gad9a5d441174d5fa9fd90d40faf82363f">More...</a><br /></td></tr>
<tr class="separator:gad9a5d441174d5fa9fd90d40faf82363f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be1d029e50234dd6271736898066403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#ga2be1d029e50234dd6271736898066403">dictobj_dictionaryfromstring</a> (<a class="el" href="structt__dictionary.html">t_dictionary</a> **d, const char *str, int str_is_already_json, char *errorstring)</td></tr>
<tr class="memdesc:ga2be1d029e50234dd6271736898066403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> from <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> which is passed in as a C-string.  <a href="#ga2be1d029e50234dd6271736898066403">More...</a><br /></td></tr>
<tr class="separator:ga2be1d029e50234dd6271736898066403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf964a2f32065e8812d829f02c82c30e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#gaf964a2f32065e8812d829f02c82c30e8">dictobj_dictionaryfromatoms</a> (<a class="el" href="structt__dictionary.html">t_dictionary</a> **d, const long argc, const <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:gaf964a2f32065e8812d829f02c82c30e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> from <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> which is passed in as an array of atoms.  <a href="#gaf964a2f32065e8812d829f02c82c30e8">More...</a><br /></td></tr>
<tr class="separator:gaf964a2f32065e8812d829f02c82c30e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82cc38d56453709803fa28c9c73f6000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#ga82cc38d56453709803fa28c9c73f6000">dictobj_dictionaryfromatoms_extended</a> (<a class="el" href="structt__dictionary.html">t_dictionary</a> **d, const <a class="el" href="structt__symbol.html">t_symbol</a> *msg, long argc, const <a class="el" href="structt__atom.html">t_atom</a> *argv)</td></tr>
<tr class="memdesc:ga82cc38d56453709803fa28c9c73f6000"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> from from an array of atoms that use Max dictionary syntax, JSON, or compressed JSON.  <a href="#ga82cc38d56453709803fa28c9c73f6000">More...</a><br /></td></tr>
<tr class="separator:ga82cc38d56453709803fa28c9c73f6000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd31e868cc743ffbd216a6be4f074d76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#gadd31e868cc743ffbd216a6be4f074d76">dictobj_dictionarytoatoms</a> (const <a class="el" href="structt__dictionary.html">t_dictionary</a> *d, long *argc, <a class="el" href="structt__atom.html">t_atom</a> **argv)</td></tr>
<tr class="memdesc:gadd31e868cc743ffbd216a6be4f074d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the contents of a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> into <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> .  <a href="#gadd31e868cc743ffbd216a6be4f074d76">More...</a><br /></td></tr>
<tr class="separator:gadd31e868cc743ffbd216a6be4f074d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab95c02717e7bd42d089c34d2b30715f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__dictobj.html#gaab95c02717e7bd42d089c34d2b30715f">dictobj_key_parse</a> (<a class="el" href="structt__object.html">t_object</a> *x, <a class="el" href="structt__dictionary.html">t_dictionary</a> *d, <a class="el" href="structt__atom.html">t_atom</a> *akey, <a class="el" href="group__misc.html#gab971e040f567bd6e834e6ca6cd272a09">t_bool</a> create, <a class="el" href="structt__dictionary.html">t_dictionary</a> **targetdict, <a class="el" href="structt__symbol.html">t_symbol</a> **targetkey, <a class="el" href="group__misc.html#ga7d4c427b5ac97669ee113c3534bc89d6">t_int32</a> *index)</td></tr>
<tr class="memdesc:gaab95c02717e7bd42d089c34d2b30715f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a complex key (one that includes potential heirarchy or array-member access), return the actual key and the dictionary in which the key should be referenced.  <a href="#gaab95c02717e7bd42d089c34d2b30715f">More...</a><br /></td></tr>
<tr class="separator:gaab95c02717e7bd42d089c34d2b30715f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Dictionary Passing API defines a means by which <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> instances may be passed between Max objects in a way similar to the way Jitter Matrices are passed between objects. </p>
<p>There are important differences, however, between Jitter matrix passing and dictionary passing. Many of these differences are documented in Max's documentation on dictionaries and structured data.</p>
<p>Every dictionary instance in this system is mapped to a unique name that identifies the dictionary. Dictionaries are passed between objects using the "dictionary" message with a single argument, which is the name of the dictionary.</p>
<h1><a class="anchor" id="using_dictobj_accessing"></a>
Registration and Access</h1>
<p>The C-API for working with these dictionaries is composed of 5 primary registration/access methods:</p>
<ul>
<li><a class="el" href="group__dictobj.html#gaa969bb93c3259b7346ac4010becb22e4" title="Register a t_dictionary with the dictionary passing system and map it to a unique name...">dictobj_register()</a> : register a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> instance with the system, and map the instance to a name</li>
<li><a class="el" href="group__dictobj.html#ga00aafb1e4ce7b94bd7a73b3620342a8c" title="Unregister a t_dictionary with the dictionary passing system. ">dictobj_unregister()</a> : unregister a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> from the system</li>
<li><a class="el" href="group__dictobj.html#gaf490af832d2059b1ff1cc8a3c34f1e4c" title="Find the t_dictionary for a given name, and return a copy of that dictionary When you are done...">dictobj_findregistered_clone()</a> : find the <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> for a given name, and return a <em>copy</em> of that dictionary</li>
<li><a class="el" href="group__dictobj.html#gaa95f7a94044a2c1bea5f4b84fc2f5620" title="Find the t_dictionary for a given name, return a pointer to that t_dictionary, and increment its refe...">dictobj_findregistered_retain()</a> : find the <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> for a given name, return a pointer to that <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a>, and increment its reference count.</li>
<li><a class="el" href="group__dictobj.html#ga893bb067b41415d9a665f0d8087f7c76" title="For a t_dictionary/name that was previously retained with dictobj_findregistered_retain(), release it (decrement its reference count). ">dictobj_release()</a> : for a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a>/name that was previously retained with <a class="el" href="group__dictobj.html#gaa95f7a94044a2c1bea5f4b84fc2f5620" title="Find the t_dictionary for a given name, return a pointer to that t_dictionary, and increment its refe...">dictobj_findregistered_retain()</a>, release it (decrement its reference count).</li>
</ul>
<p>It is useful to think of objects in the dictionary system as "nouns" and "verbs".</p>
<p>A "noun" is an object that possess or owns a dictionary. These objects are servers whose dictionary will accessed by other object that are clients. An example of a "noun" is the dict.pack object that creates a dictionary that is passed to other objects.</p>
<p>A "verb" is an object that does not maintain its own dictionary (it is not a thing) but merely does something to any dictionaries it receives. This object is a client rather than a server. An example of a "verb" is the dict.strip object, which removes entries from an existing dictionary but possesses no dictionary of its own.</p>
<p>Any object which is a dictionary "noun", can keep and rely on their dictionary pointer. Because of the way <a class="el" href="group__obj.html#gaaa97beba179d6aebd3f3ede1b5c781fa" title="Registers an object in a namespace. ">object_register()</a> works, there should be no possiblity for this pointer to change behind the scenes. They each need to call <a class="el" href="group__obj.html#ga3759846cb356195532c41e35b87522ee" title="Call the free function and release the memory for an instance of an internal object class previously ...">object_free()</a> on their respective object pointer, however. A call to <a class="el" href="group__obj.html#ga3759846cb356195532c41e35b87522ee" title="Call the free function and release the memory for an instance of an internal object class previously ...">object_free()</a> also calls <a class="el" href="group__obj.html#ga2b5b3327e03edbefe753ebd6c8b7e152" title="Removes a registered object from a namespace. ">object_unregister()</a> once, so there's technically not a need to unregister from the owner itself. They work like jit.matrix (and similar to buffer~), and use <a class="el" href="group__obj.html#gaaa97beba179d6aebd3f3ede1b5c781fa" title="Registers an object in a namespace. ">object_register()</a> to increment a server reference count. If an object has already registered an object with the given name, the pointer passed in to register is freed and the existing one is returned from the registration function.</p>
<p>Dictionary "verbs" on the other hand should just call dict_findregistered_retain() and dict_release() when done. They are not incrementing the server reference count. They increment a reference count with regards to object freeing, which is compatible with and complementary to the server reference count.</p>
<h1><a class="anchor" id="using_dictobj_syntax"></a>
Dictionary Syntax</h1>
<p>Dictionaries may be represented in a variety of textual formats including JSON. Max also supports a compact YAML-like dictionary notation which is useful for proving data structure contents as lists of atoms in object boxes. This format is documented in Max's documentation of the dictionary features. The following functions are used for formatting and parsing the dictionary syntax.</p>
<ul>
<li><a class="el" href="group__dictobj.html#gad9a5d441174d5fa9fd90d40faf82363f" title="Convert a C-string of Dictionary Syntax into a C-string of JSON. ">dictobj_jsonfromstring()</a></li>
<li><a class="el" href="group__dictobj.html#ga2be1d029e50234dd6271736898066403" title="Create a new t_dictionary from Dictionary Syntax which is passed in as a C-string. ">dictobj_dictionaryfromstring()</a></li>
<li><a class="el" href="group__dictobj.html#gaf964a2f32065e8812d829f02c82c30e8" title="Create a new t_dictionary from Dictionary Syntax which is passed in as an array of atoms...">dictobj_dictionaryfromatoms()</a></li>
<li><a class="el" href="group__dictobj.html#gadd31e868cc743ffbd216a6be4f074d76" title="Serialize the contents of a t_dictionary into Dictionary Syntax . ">dictobj_dictionarytoatoms()</a></li>
</ul>
<h1><a class="anchor" id="using_dictobj_utilities"></a>
Utilities</h1>
<p>There are several utility functions available to assist in coding objects that pass dictionaries.</p>
<ul>
<li><a class="el" href="group__dictobj.html#ga6b50af649740589d8a86c114d8499621" title="Send atoms to an outlet in your Max object, handling complex datatypes that may be present in those a...">dictobj_outlet_atoms()</a></li>
<li><a class="el" href="group__dictobj.html#gaf42c50812bf8215eda9bcb0595ecf213" title="Ensure that an atom is safe for passing. ">dictobj_atom_safety()</a></li>
<li><a class="el" href="group__dictobj.html#ga16fa5b430f0116b582d0909604d34a67" title="Validate the contents of a t_dictionary against a second t_dictionary containing a schema...">dictobj_validate()</a></li>
</ul>
<p>The <a class="el" href="group__dictobj.html#ga16fa5b430f0116b582d0909604d34a67" title="Validate the contents of a t_dictionary against a second t_dictionary containing a schema...">dictobj_validate()</a> object is a utility routine for validating a dictionary against "schema" dictionary. This enables a behavior somewhat analogous to Objective-C or Smalltalk prototypes. Dictionary validation can be useful to implement a kind of dictionary polymorphism. For a multiple-inheritance behavior, simply validate a dictionary against multiple schemas to verify the presence of required keys and values.</p>
<h1><a class="anchor" id="using_dictobj_limitations"></a>
Limitations</h1>
<p>The dict_outlet_atoms() function will not output <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a82cc76e0d53c8fc28df167c35d5bbd1a" title="t_object pointer (for argtype lists; passes the value of sym) ">A_OBJ</a> atoms directly (nor should any other object) and as such it will also not output <a class="el" href="structt__atomarray.html" title="The atomarray object. ">t_atomarray</a> instances containing objects, thus atomarrays are <em>not</em> hierarchical in the dictionary passing implementation.</p>
<p>It will output an atom array if provided a single A_OBJ atom with class atomarray. If there is an array of atoms which contain A_OBJ atoms, they are converted to the *symbols* &lt;dictionary-object&gt;, &lt;atomarray-object&gt;, &lt;string-object&gt;, &lt;other-object&gt; respectively. Ideally such a case should never be reached if everything which inserts values into a dictionary is well behaved&ndash;i.e.</p>
<ul>
<li>a key may be a single atom</li>
<li>a key may be an atomarray (but no A_OBJ atoms)</li>
<li>a key may be a dictionary</li>
</ul>
<dl class="section version"><dt>Version</dt><dd>6.0 </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaf42c50812bf8215eda9bcb0595ecf213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long dictobj_atom_safety </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that an atom is safe for passing. </p>
<p>Atoms are allowed to be <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer ">A_LONG</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a0b3aa0ab8104573dfc9cb70b5b08031f" title="32-bit float ">A_FLOAT</a>, or <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a2d661c2a5d949566e2f1944c99bceeea" title="t_symbol pointer ">A_SYM</a>, but not <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a82cc76e0d53c8fc28df167c35d5bbd1a" title="t_object pointer (for argtype lists; passes the value of sym) ">A_OBJ</a>. If the atom is an <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a82cc76e0d53c8fc28df167c35d5bbd1a" title="t_object pointer (for argtype lists; passes the value of sym) ">A_OBJ</a>, it will be converted into something that will be safe to pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An atom to check, and potentially modify, to ensure safety in the dictionary-passing system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the atom was changed then 1 is returned. Otherwise 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4a857a7c9c5d852126c87e5a8968a1a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long dictobj_atom_safety_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that an atom is safe for passing. </p>
<p>Atoms are allowed to be <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a002f28879581a6f66ea492b994b96f1e" title="long integer ">A_LONG</a>, <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a0b3aa0ab8104573dfc9cb70b5b08031f" title="32-bit float ">A_FLOAT</a>, or <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a2d661c2a5d949566e2f1944c99bceeea" title="t_symbol pointer ">A_SYM</a>, but not <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a82cc76e0d53c8fc28df167c35d5bbd1a" title="t_object pointer (for argtype lists; passes the value of sym) ">A_OBJ</a>. If the atom is an <a class="el" href="group__atom.html#gga8aa6700e9f00b132eb376db6e39ade47a82cc76e0d53c8fc28df167c35d5bbd1a" title="t_object pointer (for argtype lists; passes the value of sym) ">A_OBJ</a>, it will be converted into something that will be safe to pass.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>An atom to check, and potentially modify, to ensure safety in the dictionary-passing system. </td></tr>
    <tr><td class="paramname">flags</td><td>Pass DICTOBJ_ATOM_FLAGS_REGISTER to have dictionary atoms registered/retained. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the atom was changed then 1 is returned. Otherwise 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf964a2f32065e8812d829f02c82c30e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> dictobj_dictionaryfromatoms </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> **&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> from <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> which is passed in as an array of atoms. </p>
<p>Unlike many <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> calls to create dictionaries, this function does not take over ownership of the atoms you pass in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The address of a dictionary variable, which will hold a pointer to the new dictionary upon return. Should be initialized to NULL. </td></tr>
    <tr><td class="paramname">argc</td><td>The number of atoms in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>Pointer to the first of an array of atoms to be interpreted as <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#ga82cc38d56453709803fa28c9c73f6000" title="Create a new t_dictionary from from an array of atoms that use Max dictionary syntax, JSON, or compressed JSON. ">dictobj_dictionaryfromatoms_extended()</a> <a class="el" href="group__dictobj.html#gadd31e868cc743ffbd216a6be4f074d76" title="Serialize the contents of a t_dictionary into Dictionary Syntax . ">dictobj_dictionarytoatoms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga82cc38d56453709803fa28c9c73f6000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> dictobj_dictionaryfromatoms_extended </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> **&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> from from an array of atoms that use Max dictionary syntax, JSON, or compressed JSON. </p>
<p>This function is the C analog to the dict.deserialize object in Max. Unlike many <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> calls to create dictionaries, this function does not take over ownership of the atoms you pass in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The address of a dictionary variable, which will hold a pointer to the new dictionary upon return. Should be initialized to NULL. </td></tr>
    <tr><td class="paramname">msg</td><td>Ignored. </td></tr>
    <tr><td class="paramname">argc</td><td>The number of atoms in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>Pointer to the first of an array of atoms to be interpreted as <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> , JSON, or compressed JSON. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#gaf964a2f32065e8812d829f02c82c30e8" title="Create a new t_dictionary from Dictionary Syntax which is passed in as an array of atoms...">dictobj_dictionaryfromatoms()</a> <a class="el" href="group__dictobj.html#ga2be1d029e50234dd6271736898066403" title="Create a new t_dictionary from Dictionary Syntax which is passed in as a C-string. ">dictobj_dictionaryfromstring()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2be1d029e50234dd6271736898066403"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> dictobj_dictionaryfromstring </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> **&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>str_is_already_json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errorstring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> from <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> which is passed in as a C-string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The address of a dictionary variable, which will hold a pointer to the new dictionary upon return. Should be initialized to NULL. </td></tr>
    <tr><td class="paramname">str</td><td>A NULL-terminated C-string containing <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> . </td></tr>
    <tr><td class="paramname">str_is_already_json</td><td></td></tr>
    <tr><td class="paramname">errorstring</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#gadd31e868cc743ffbd216a6be4f074d76" title="Serialize the contents of a t_dictionary into Dictionary Syntax . ">dictobj_dictionarytoatoms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadd31e868cc743ffbd216a6be4f074d76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> dictobj_dictionarytoatoms </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Serialize the contents of a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> into <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> . </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The dictionary to serialize. </td></tr>
    <tr><td class="paramname">argc</td><td>The address of a variable to hold the number of atoms allocated upon return. </td></tr>
    <tr><td class="paramname">argv</td><td>The address of a <a class="el" href="structt__atom.html" title="An atom is a typed datum. ">t_atom</a> pointer which will point to the first atom (of an array of argc atoms) upon return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#gaf964a2f32065e8812d829f02c82c30e8" title="Create a new t_dictionary from Dictionary Syntax which is passed in as an array of atoms...">dictobj_dictionaryfromatoms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf490af832d2059b1ff1cc8a3c34f1e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__dictionary.html">t_dictionary</a>* dictobj_findregistered_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> for a given name, and return a <em>copy</em> of that dictionary When you are done, do <em>not</em> call <a class="el" href="group__dictobj.html#ga893bb067b41415d9a665f0d8087f7c76" title="For a t_dictionary/name that was previously retained with dictobj_findregistered_retain(), release it (decrement its reference count). ">dictobj_release()</a> on the dictionary, because you are working on a copy rather than on a retained pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name associated with the dictionary for which you wish to obtain a copy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dictionary cloned from the existing dictionary. Returns NULL if no dictionary is associated with name. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#gaa95f7a94044a2c1bea5f4b84fc2f5620" title="Find the t_dictionary for a given name, return a pointer to that t_dictionary, and increment its refe...">dictobj_findregistered_retain()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa95f7a94044a2c1bea5f4b84fc2f5620"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__dictionary.html">t_dictionary</a>* dictobj_findregistered_retain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> for a given name, return a pointer to that <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a>, and increment its reference count. </p>
<p>When you are done you should call <a class="el" href="group__dictobj.html#ga893bb067b41415d9a665f0d8087f7c76" title="For a t_dictionary/name that was previously retained with dictobj_findregistered_retain(), release it (decrement its reference count). ">dictobj_release()</a> on the dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name associated with the dictionary for which you wish to obtain a pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the dictionary associated with name. Returns NULL if no dictionary is associated with name. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#ga893bb067b41415d9a665f0d8087f7c76" title="For a t_dictionary/name that was previously retained with dictobj_findregistered_retain(), release it (decrement its reference count). ">dictobj_release()</a> </dd>
<dd>
<a class="el" href="group__dictobj.html#gaf490af832d2059b1ff1cc8a3c34f1e4c" title="Find the t_dictionary for a given name, and return a copy of that dictionary When you are done...">dictobj_findregistered_clone()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gad9a5d441174d5fa9fd90d40faf82363f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> dictobj_jsonfromstring </td>
          <td>(</td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>jsonsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a C-string of <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> into a C-string of JSON. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">jsonsize</td><td>The address of a variable to be filled-in with the number of chars in json upon return. </td></tr>
    <tr><td class="paramname">json</td><td>The address of a char pointer to point to the JSON C-string upon return. Should be initialized to NULL. You are responsible for freeing the string with <a class="el" href="group__memory.html#ga200c82639e547869db1f3887d17102d3" title="Free memory allocated with sysmem_newptr(). ">sysmem_freeptr()</a> when you are done with it. </td></tr>
    <tr><td class="paramname">str</td><td>A NULL-terminated C-string containing <a class="el" href="group__dictobj.html#using_dictobj_syntax">Dictionary Syntax</a> . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#gadd31e868cc743ffbd216a6be4f074d76" title="Serialize the contents of a t_dictionary into Dictionary Syntax . ">dictobj_dictionarytoatoms()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaab95c02717e7bd42d089c34d2b30715f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> dictobj_key_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__object.html">t_object</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>akey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__misc.html#gab971e040f567bd6e834e6ca6cd272a09">t_bool</a>&#160;</td>
          <td class="paramname"><em>create</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> **&#160;</td>
          <td class="paramname"><em>targetdict</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> **&#160;</td>
          <td class="paramname"><em>targetkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__misc.html#ga7d4c427b5ac97669ee113c3534bc89d6">t_int32</a> *&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a complex key (one that includes potential heirarchy or array-member access), return the actual key and the dictionary in which the key should be referenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Your calling object. If there is an error this will be used by the internal call to <a class="el" href="group__console.html#ga7622564965cfebaf51169ce60175504a" title="Print text to the Max window, linked to an instance of your object, and flagged as an error (highligh...">object_error()</a>. </td></tr>
    <tr><td class="paramname">d</td><td>The dictionary you are querying. </td></tr>
    <tr><td class="paramname">akey</td><td>The complex key specifying the query. </td></tr>
    <tr><td class="paramname">create</td><td>If true, create the intermediate dictionaries in the hierarchy specified in akey. </td></tr>
    <tr><td class="paramname">targetdict</td><td>Returns the <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> that for the (sub)dictionary specified by akey. </td></tr>
    <tr><td class="paramname">targetkey</td><td>Returns the name of the key in targetdict that to which akey is referencing. </td></tr>
    <tr><td class="paramname">index</td><td>Returns the index requested if array-member access is specified. Pass NULL if you are not interested in this.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga82b86e621c2e9a280d0ed266710a1a76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structt__symbol.html">t_symbol</a>* dictobj_namefromptr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the name associated with a given <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>A dictionary, whose name you wish to determine. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The symbol associated with the dictionary, or NULL if the dictionary is not registered. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#gaa969bb93c3259b7346ac4010becb22e4" title="Register a t_dictionary with the dictionary passing system and map it to a unique name...">dictobj_register()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b50af649740589d8a86c114d8499621"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dictobj_outlet_atoms </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__atom.html">t_atom</a> *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send atoms to an outlet in your Max object, handling complex datatypes that may be present in those atoms. </p>
<p>This is particularly when sending the contents of a dictionary entry out of an outlet as in the following example code.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;long       ac = 0;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;t_atom     *av = NULL;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;t_max_err  err;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;err = dictionary_copyatoms(d, key, &amp;ac, &amp;av);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;if (!err &amp;&amp; ac &amp;&amp; av) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;   // handles singles, lists, symbols, atomarrays, dictionaries, etc.</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;   dictobj_outlet_atoms(x-&gt;outlets[i],ac,av);</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;}</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;if (av)</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;   sysmem_freeptr(av);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out</td><td>The outlet through which the atoms should be sent. </td></tr>
    <tr><td class="paramname">argc</td><td>The count of atoms in argv. </td></tr>
    <tr><td class="paramname">argv</td><td>Pointer to the first of an array of atoms to send to the outlet. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa969bb93c3259b7346ac4010becb22e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#ga06f35de4fc025809ab1cbb06f55b6495">BEGIN_USING_C_LINKAGE</a> <a class="el" href="structt__dictionary.html">t_dictionary</a>* dictobj_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structt__symbol.html">t_symbol</a> **&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> with the dictionary passing system and map it to a unique name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>A valid dictionary object. </td></tr>
    <tr><td class="paramname">name</td><td>The address of a <a class="el" href="structt__symbol.html" title="The symbol. ">t_symbol</a> pointer to the name you would like mapped to this dictionary. If the <a class="el" href="structt__symbol.html" title="The symbol. ">t_symbol</a> pointer has a NULL value then a unique name will be generated and filled-in upon return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dictionary mapped to the specified name. </dd></dl>

</div>
</div>
<a class="anchor" id="ga893bb067b41415d9a665f0d8087f7c76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> dictobj_release </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a>/name that was previously retained with <a class="el" href="group__dictobj.html#gaa95f7a94044a2c1bea5f4b84fc2f5620" title="Find the t_dictionary for a given name, return a pointer to that t_dictionary, and increment its refe...">dictobj_findregistered_retain()</a>, release it (decrement its reference count). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>A valid dictionary object retained by <a class="el" href="group__dictobj.html#gaa95f7a94044a2c1bea5f4b84fc2f5620" title="Find the t_dictionary for a given name, return a pointer to that t_dictionary, and increment its refe...">dictobj_findregistered_retain()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#gaa95f7a94044a2c1bea5f4b84fc2f5620" title="Find the t_dictionary for a given name, return a pointer to that t_dictionary, and increment its refe...">dictobj_findregistered_retain()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga00aafb1e4ce7b94bd7a73b3620342a8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__misc.html#gaace8607dfb500e6dcca022a35fcb8386">t_max_err</a> dictobj_unregister </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregister a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> with the dictionary passing system. </p>
<p>Generally speaking you should not need to call this method. Calling <a class="el" href="group__obj.html#ga3759846cb356195532c41e35b87522ee" title="Call the free function and release the memory for an instance of an internal object class previously ...">object_free()</a> on the <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> automatically unregisters it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>A valid dictionary object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Max error code. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16fa5b430f0116b582d0909604d34a67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long dictobj_validate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td>
          <td class="paramname"><em>schema</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structt__dictionary.html">t_dictionary</a> *&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Validate the contents of a <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> against a second <a class="el" href="structt__dictionary.html" title="The dictionary object. ">t_dictionary</a> containing a schema. </p>
<p>The schema dictionary contains keys and values, like any dictionary. <a class="el" href="group__dictobj.html#ga16fa5b430f0116b582d0909604d34a67" title="Validate the contents of a t_dictionary against a second t_dictionary containing a schema...">dictobj_validate()</a> checks to make sure that all keys in the schema dictionary are present in the candidate dictionary. If the keys are all present then the candidate passes and the function returns true. Otherwise the the candidate fails the validation and the function returns false.</p>
<p>Generally speaking, the schema dictionary with contain values with the symbol "*", indicating a wildcard, and thus only the key is used to validate the dictionary (all values match the wildcard). However, if the schema dictionary contains non-wildcard values for any of its keys, those keys in the candidate dictionary must also contain matching values in order for the candidate to successfully validate.</p>
<p>An example of this in action is the dict.route object in Max, which simply wraps this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">schema</td><td>The dictionary against which to validate candidate. </td></tr>
    <tr><td class="paramname">candidate</td><td>A dictionary to test against the schema. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the candidate validates against the schema, otherwise returns false. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__dictobj.html#gadd31e868cc743ffbd216a6be4f074d76" title="Serialize the contents of a t_dictionary into Dictionary Syntax . ">dictobj_dictionarytoatoms()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
		<div id="c74footer">
			&nbsp;&nbsp;Copyright &copy; 2015, <a href="http://www.cycling74.com/">Cycling '74</a>
		</div>
	</body>
</html>
